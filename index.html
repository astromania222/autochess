<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto Chess</title>
    <link rel="stylesheet" href="https://nagoshiashumari.github.io/Rpg-Awesome/stylesheets/rpg-awesome.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Times New Roman', 'YuMincho', 'Hiragino Mincho ProN', serif;
            background: #1c1a16;
            color: #d4c5a3;
            min-height: 100vh;
            overflow-x: hidden;
            background-image: radial-gradient(circle at center, #2e2a24 0%, #1c1a16 100%);
        }

        /* ===== HEADER ===== */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: #2b2520;
            border-bottom: 3px solid #c5a059;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
        }

        .header-info {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stage-badge {
            background: linear-gradient(135deg, #5c4d3c, #3e3529);
            border: 1px solid #8c7b64;
            padding: 8px 20px;
            border-radius: 4px;
            font-weight: bold;
            color: #f0e6d2;
            box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
        }

        .gold-display {
            color: #ffd700;
            font-weight: bold;
            font-size: 1.1rem;
            text-shadow: 0 0 2px #b8860b;
        }

        .health-bar {
            padding: 5px 15px;
            border-radius: 4px;
            font-weight: bold;
            border: 1px solid #4a4036;
        }

        #player-health {
            background: linear-gradient(90deg, #4a7c59, #2d4f36);
            color: #e6dfcc;
            border-color: #6b8c73;
        }

        #opponent-health {
            background: linear-gradient(90deg, #8c4a4a, #592d2d);
            color: #e6dfcc;
            border-color: #a65e5e;
        }

        /* ===== MAIN LAYOUT ===== */
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 20px 0 20px;
            position: relative;
        }

        .game-area {
            display: flex;
            flex-direction: column;
            gap: 0;
            /* Connected boards */
            align-items: center;
            background: rgba(20, 18, 15, 0.4);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #4a4036;
        }

        /* ===== BOARDS ===== */
        .board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            gap: 5px;
            padding: 15px;
            background: rgba(30, 26, 22, 0.6);
            border-radius: 4px;
            justify-content: center;
            border: 1px solid #5c4d3c;
            width: 490px;
            /* Fixed width: 7 cells * 60px + 6 gaps * 5px + padding */
        }

        .hex-cell {
            width: 60px;
            height: 60px;
            background: #363028;
            border: 2px solid #52483a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            transition: all 0.2s;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.4);
        }

        .hex-cell:hover {
            background: #4d4438;
            border-color: #c5a059;
        }

        .hex-cell.valid-target {
            border-color: #6b8c73;
        }

        .hex-cell.drag-over {
            background: rgba(107, 140, 115, 0.4);
            transform: scale(1.05);
        }

        .bot-area {
            opacity: 0.9;
        }

        .bot-area .hex-cell {
            background: #3a2828;
            border-color: #5e3b3b;
        }

        .player-area {
            /* Same structure as bot-area for consistency */
        }

        /* ===== UNITS ===== */
        .unit {
            width: 52px;
            height: 52px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: bold;
            cursor: grab;
            position: relative;
            transition: transform 0.15s, box-shadow 0.15s;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.9);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            border: 1px solid #000;
        }

        .unit .unit-bg-icon {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 34px;
            opacity: 0.4;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 0;
            filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.5));
            pointer-events: none;
        }

        .unit .u-name {
            /* Removed absolute positioning to let flexbox center it */
            position: relative;
            width: 100%;
            text-align: center;
            font-size: 0.6rem;
            line-height: 0.9;
            white-space: normal;
            word-break: break-all;
            padding: 0 1px;
            pointer-events: none;
            color: #fff;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 20px;
            text-shadow:
                -1px -1px 0 #000,
                1px -1px 0 #000,
                -1px 1px 0 #000,
                1px 1px 0 #000,
                0 0 4px #000;
            z-index: 10;
        }

        .unit:hover {
            transform: scale(1.1);
            z-index: 50;
            border-color: #c5a059;
        }

        .unit.selected {
            box-shadow: 0 0 15px #c5a059;
            border-color: #c5a059;
        }

        .unit.player {
            border: 2px solid #6b8c73;
            /* Greenish */
        }

        .unit.enemy {
            border: 2px solid #a65e5e;
            /* Reddish */
        }

        .unit.tier-1 {
            background: linear-gradient(135deg, #6e6e6e, #4a4a4a);
            /* Iron/Grey */
            color: #e0e0e0;
        }

        .unit.tier-2 {
            background: linear-gradient(135deg, #4da674, #2d5e40);
            /* Green/Forest */
            color: #fff;
        }

        .unit.tier-3 {
            background: linear-gradient(135deg, #4aa3cc, #2a5d7a);
            /* Blue/River */
            color: #fff;
        }

        .unit.tier-4 {
            background: linear-gradient(135deg, #a34acc, #5d2a7a);
            /* Purple/Royal */
            color: #fff;
        }

        .unit.tier-5 {
            background: linear-gradient(135deg, #cca34a, #8c6e2d);
            /* Gold/Legendary */
            color: #fff;
        }

        .hp-bar-container {
            position: absolute;
            bottom: -6px;
            left: 2px;
            right: 2px;
            height: 5px;
            background: #1a1b26;
            border-radius: 3px;
            overflow: hidden;
            pointer-events: none;
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #9ece6a, #73daca);
            transition: width 0.2s;
            position: absolute;
            left: 0;
        }

        .shield-bar-fill {
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            transition: width 0.2s;
            position: absolute;
        }

        .star-indicator {
            position: absolute;
            top: -8px;
            right: -4px;
            color: gold;
            text-shadow: 0 0 3px #000;
            font-size: 0.7rem;
            pointer-events: none;
        }

        .unit.attacking {
            transform: scale(1.3);
            box-shadow: 0 0 20px red !important;
            z-index: 100;
        }

        /* ===== MANA BAR ===== */
        .hp-bar-container {
            position: absolute;
            bottom: -6px;
            left: 2px;
            right: 2px;
            height: 5px;
            background: #1a1b26;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        .hp-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #9ece6a, #73daca);
            transition: width 0.2s;
            position: absolute;
            left: 0;
        }

        .shield-bar-fill {
            height: 100%;
            background: rgba(255, 255, 255, 0.7);
            transition: width 0.2s;
            position: absolute;
        }

        .mana-bar-container {
            position: absolute;
            bottom: -12px;
            left: 2px;
            right: 2px;
            height: 4px;
            background: #1a1b26;
            border-radius: 2px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            pointer-events: none;
        }

        .mana-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #7aa2f7, #7dcfff);
            transition: width 0.3s ease;
        }

        /* ===== ITEM SLOTS ===== */
        .item-slots {
            position: absolute;
            top: -12px;
            left: 2px;
            display: flex;
            gap: 1px;
        }

        .item-mini-icon {
            width: 14px;
            height: 14px;
            background: #24283b;
            border: 1px solid #7aa2f7;
            border-radius: 2px;
            background-size: cover;
        }

        .unit.upgrading {
            animation: upgradeGlow 0.5s ease-in-out;
            box-shadow: 0 0 30px gold !important;
            z-index: 200;
        }

        @keyframes upgradeGlow {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.3);
            }
        }

        /* ===== UNIT TOOLTIP ===== */
        .unit-tooltip {
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background: #2b2520;
            border: 2px solid #c5a059;
            /* Gold border */
            border-radius: 4px;
            padding: 12px;
            min-width: 180px;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.75rem;
            text-align: left;
            white-space: nowrap;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.8);
            font-family: 'Times New Roman', serif;
            color: #e6dfcc;
        }

        .unit:hover .unit-tooltip {
            opacity: 1;
        }

        .unit-tooltip .tt-name {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffd700;
            /* Gold */
            margin-bottom: 6px;
            border-bottom: 1px solid #5c4d3c;
            padding-bottom: 4px;
        }

        .unit-tooltip .tt-stars {
            color: #ffd700;
        }

        .unit-tooltip .tt-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }

        .unit-tooltip .tt-label {
            color: #888;
        }

        .unit-tooltip .tt-label::after,
        #unit-detail-box .tt-label::after {
            content: ":";
            margin-left: 2px;
        }

        .unit-tooltip .tt-value {
            color: #fff;
            font-weight: bold;
        }

        .unit-tooltip .tt-traits {
            color: #bb9af7;
            margin-top: 6px;
            font-size: 0.7rem;
        }

        .unit-tooltip .tt-sell {
            color: #e0af68;
            margin-top: 8px;
            padding-top: 6px;
            border-top: 1px solid #444;
        }

        /* ===== BENCH ===== */
        .bench-container {
            display: flex;
            gap: 8px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 10px;
            margin: 4px 0;
            position: relative;
            z-index: 1;
        }

        .slot {
            width: 60px;
            height: 60px;
            background: rgba(65, 72, 104, 0.4);
            border: 2px dashed #414868;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot.drag-over {
            background: rgba(158, 206, 106, 0.3);
            border-color: #9ece6a;
        }

        /* ===== SHOP ===== */
        .shop-container {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 4px;
            position: relative;
            z-index: 2000;
        }

        .shop-card {
            width: 120px;
            padding: 10px 6px;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid #4a4036;
            position: relative;
            background: #2b2520;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
        }

        .shop-card:hover .unit-tooltip {
            opacity: 1;
        }

        .shop-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
            border-color: #c5a059;
        }

        .shop-card.tier-1 {
            border-top: 4px solid #6e6e6e;
        }

        .shop-card.tier-2 {
            border-top: 4px solid #4da674;
        }

        .shop-card.tier-3 {
            border-top: 4px solid #4aa3cc;
        }

        .shop-card.tier-4 {
            border-top: 4px solid #a34acc;
        }

        .shop-card.tier-5 {
            border-top: 4px solid #cca34a;
        }

        /* ===== CONTROLS ===== */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: center;
        }

        button {
            padding: 10px 20px;
            border: 2px solid #5c4d3c;
            border-radius: 4px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Times New Roman', serif;
            background: linear-gradient(180deg, #3e3529, #2b2520);
            color: #f0e6d2;
            box-shadow: 0 4px 0 #1a1814;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-2px);
            background: linear-gradient(180deg, #4d4438, #3a322b);
            border-color: #c5a059;
            color: #fff;
            box-shadow: 0 6px 0 #1a1814;
        }

        button:active {
            transform: translateY(2px);
            box-shadow: 0 2px 0 #1a1814;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            filter: grayscale(0.8);
        }

        #btn-start {
            background: linear-gradient(180deg, #8c4a4a, #592d2d);
            border-color: #a65e5e;
            box-shadow: 0 4px 0 #3b1e1e;
        }

        #btn-start:hover {
            background: linear-gradient(180deg, #a35e5e, #7a3e3e);
            border-color: #ff6b6b;
            box-shadow: 0 6px 0 #3b1e1e;
        }

        /* ===== SYNERGY PANELS ===== */
        #synergy-panel,
        #bot-synergy-panel {
            position: fixed;
            top: 100px;
            width: 150px;
            display: flex;
            flex-direction: column;
            gap: 6px;
            z-index: 100;
        }

        /* ===== UNIT DETAIL BOX (Side Panel) ===== */
        #unit-detail-box {
            /* Visibility controlled by inline styles via showUnitDetail/hideUnitDetail */
            font-size: 0.75rem;
            text-align: left;
            font-family: 'Times New Roman', serif;
            color: #d4c5a3;
        }

        /* Hide floating tooltip for units on board */
        .board .unit .unit-tooltip {
            display: none !important;
        }

        #opponent-board {
            padding-bottom: 5px;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
        }

        #player-board {
            padding-top: 5px;
            border-top-left-radius: 0;
            border-top-right-radius: 0;
        }

        /* ===== DROP TABLE ===== */
        #drop-table-container {
            position: fixed;
            top: 640px;
            left: 230px;

            background: rgba(43, 37, 32, 0.95);
            padding: 10px;
            border-radius: 4px;
            border: 2px solid #5c4d3c;
            font-size: 0.7rem;
            z-index: 90;
            width: 210px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            color: #d4c5a3;
        }

        .drop-row {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
            padding: 2px 4px;
            border-radius: 4px;
        }

        .drop-row.current-lv {
            background: rgba(197, 160, 89, 0.2);
            border: 1px solid #c5a059;
        }

        .tier-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 4px;
        }

        #synergy-panel {
            position: fixed;
            top: 250px;
            left: 15px;
            /* Restored to original position */
        }

        #bot-synergy-panel {
            position: fixed;
            top: 250px;
            right: 15px;
        }

        .synergy-item {
            background: rgba(43, 37, 32, 0.95);
            padding: 8px 12px;
            font-size: 0.8rem;
            border-radius: 2px;
            color: #a09585;
            border: 1px solid #4a4036;
            border-left: 4px solid #4a4036;
            cursor: pointer;
            position: relative;
            font-family: 'Times New Roman', serif;
        }

        .synergy-item:hover {
            background: #3e3529;
            color: #f0e6d2;
        }

        .synergy-item .synergy-tooltip {
            position: fixed;
            background: #2b2520;
            border: 1px solid #c5a059;
            border-radius: 4px;
            padding: 10px;
            min-width: 200px;
            z-index: 5000;
            display: none;
            pointer-events: none;
            font-size: 0.75rem;
            white-space: pre-wrap;
            color: #d4c5a3;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.8);
        }

        /* Tooltip shown via JS onmouseenter */


        /* Tooltip positioning handled by JS for both panels */

        /* ===== ITEM GUIDE PANEL ===== */
        #item-guide-panel {
            position: fixed;
            top: 100px;
            right: 430px;
            width: 250px;
            height: 400px;
            background: #2b2520;
            border: 2px solid #5c4d3c;
            border-radius: 4px;
            padding: 0;
            z-index: 95;
            color: #d4c5a3;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            font-family: 'Times New Roman', serif;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.6);
        }

        .guide-tabs {
            display: flex;
            background: #1c1a16;
            border-bottom: 2px solid #5c4d3c;
        }

        .guide-tab {
            flex: 1;
            text-align: center;
            padding: 8px;
            cursor: pointer;
            font-size: 0.75rem;
            color: #8c7b64;
            font-weight: bold;
            transition: 0.2s;
        }

        .guide-tab.active {
            color: #ffd700;
            background: #3e3529;
            border-bottom: 2px solid #ffd700;
        }

        .guide-content {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .guide-section-title {
            color: #c5a059;
            font-size: 0.75rem;
            margin-bottom: 5px;
            border-bottom: 1px solid #4a4036;
            padding-bottom: 2px;
            font-weight: bold;
        }

        .rec-row {
            display: flex;
            align-items: center;
            margin-bottom: 4px;
            padding: 4px;
            background: #1f1d19;
            border-radius: 2px;
            border: 1px solid #363028;
        }

        .item-icon-box {
            width: 24px;
            height: 24px;
            border-radius: 2px;
            margin-right: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 14px;
            background: #151412;
            border: 1px solid #4a4036;
            position: relative;
        }

        .item-icon-box.mat-1 {
            border-color: #6e6e6e;
            color: #e0e0e0;
            /* Sword */
        }

        .item-icon-box.mat-2 {
            border-color: #4da674;
            color: #4da674;
            /* Bow */
        }

        .item-icon-box.mat-3 {
            border-color: #4aa3cc;
            color: #4aa3cc;
            /* Rod */
        }

        .item-icon-box.mat-4 {
            border-color: #a34acc;
            color: #a34acc;
            /* Tear */
        }

        .item-icon-box.mat-5 {
            border-color: #cca34a;
            color: #cca34a;
            /* Vest */
        }

        .item-icon-box.mat-6 {
            border-color: #8c4a4a;
            color: #8c4a4a;
            /* Cloak */
        }

        .item-icon-box.mat-7 {
            border-color: #5d2a7a;
            color: #5d2a7a;
            /* Belt */
        }

        .item-icon-box.mat-8 {
            border-color: #8c6e2d;
            color: #8c6e2d;
            /* Glove */
        }

        .item-icon-box.mat-9 {
            border-color: #ffd700;
            color: #ffd700;
            /* Spatula */
        }

        .rec-desc {
            font-size: 0.7rem;
            color: #a09585;
        }

        .rec-name {
            font-weight: bold;
            color: #c5a059;
            font-size: 0.75rem;
        }

        #bot-synergy-panel .synergy-item {
            border-left: none;
            border-right: 4px solid #4a4036;
            text-align: right;
        }

        .synergy-item.active-bronze {
            border-color: #cd7f32;
            color: #fff;
        }

        .synergy-item.active-silver {
            border-color: #c0c0c0;
            color: #fff;
        }

        .synergy-item.active-gold {
            border-color: #ffd700;
            color: #fff;
            text-shadow: 0 0 5px gold;
        }

        #bot-synergy-panel .synergy-item.active-bronze {
            border-right-color: #cd7f32;
        }

        #bot-synergy-panel .synergy-item.active-silver {
            border-right-color: #c0c0c0;
        }

        #bot-synergy-panel .synergy-item.active-gold {
            border-right-color: #ffd700;
        }

        /* ===== SELL ZONE ===== */
        #sell-zone {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 80px;

            height: 80px;
            background: rgba(247, 118, 142, 0.3);
            border: 3px dashed #f7768e;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #f7768e;
            font-size: 0.9rem;
        }

        #sell-zone.visible {
            display: flex;
        }

        /* ===== DAMAGE POPUP ===== */
        .hit-damage {
            position: fixed;
            font-weight: 900;
            z-index: 5000;
            pointer-events: none;
            animation: popUp 0.8s ease-out forwards;
            font-size: 1.25rem;
            text-shadow: 0 0 4px rgba(0, 0, 0, 1), 0 0 8px rgba(0, 0, 0, 1);
            white-space: nowrap;
        }

        .hit-damage.ad {
            color: #ff9e64 !important;
        }

        /* Orange for AD */
        .hit-damage.ap {
            color: #0066cc !important;
            /* Dark Blue for AP damage */
            text-shadow: 0 0 10px #0066cc, 0 0 20px #0066cc;
            font-weight: bold;
        }

        /* Blue for AP */
        .hit-damage.crit {
            color: #ff3333 !important;
        }

        /* Red for Crit */
        .hit-damage.true {
            color: #ffffff !important;
        }

        /* White for True */
        .hit-damage.heal {
            color: #00ff00 !important;
            text-shadow: 0 0 8px #00ff00, 0 0 4px rgba(0, 0, 0, 1);
            font-weight: bold;
        }

        .hit-damage.mana {
            color: #7dcfff !important;
            /* Light blue for mana recovery */
            text-shadow: 0 0 8px #7dcfff, 0 0 4px rgba(0, 0, 0, 1);
            font-weight: bold;
        }

        /* Status Effect Text */
        .status-text {
            position: absolute;
            top: -20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.6rem;
            font-weight: bold;
            padding: 1px 4px;
            border-radius: 3px;
            z-index: 100;
            white-space: nowrap;
            animation: statusPulse 1s infinite;
        }

        .status-text.frozen {
            background: rgba(100, 200, 255, 0.8);
            color: #fff;
        }

        .status-text.stunned {
            background: rgba(255, 200, 50, 0.8);
            color: #000;
        }

        .status-text.burning {
            background: rgba(255, 100, 50, 0.8);
            color: #fff;
        }

        /* Status Effect Icons */
        .status-icon {
            position: absolute;
            top: -16px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            z-index: 100;
            animation: statusPulse 1s infinite;
        }

        @keyframes statusPulse {

            0%,
            100% {
                opacity: 1;
                transform: translateX(-50%) scale(1);
            }

            50% {
                opacity: 0.6;
                transform: translateX(-50%) scale(1.2);
            }
        }

        /* Synergy Highlight */
        .synergy-item.highlight {
            animation: synergyFlash 0.5s ease-out;
        }

        @keyframes synergyFlash {
            0% {
                box-shadow: 0 0 20px gold;
                background: rgba(255, 215, 0, 0.3);
            }

            100% {
                box-shadow: none;
                background: rgba(30, 32, 48, 0.95);
            }
        }

        /* ===== INVENTORY ===== */
        #inventory-container {
            position: fixed;
            top: 535px;
            left: 230px;
            display: grid;
            grid-template-rows: repeat(2, 42px);
            grid-template-columns: repeat(8, 42px);
            gap: 4px;
            width: 380px;
            height: 100px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 10px;
            border: 1px solid #414868;
            backdrop-filter: blur(5px);
            justify-content: center;
            align-content: center;
        }

        #augment-list-container {
            position: fixed;
            top: 640px;
            left: calc(100% - 500px);
            right: auto;
            bottom: auto;
            display: flex;
            gap: 5px;
            width: auto;
            max-width: 600px;
            align-items: flex-start;
            flex-direction: row;
            /* Horizontal layout */
            flex-wrap: wrap;
            padding: 10px;
            pointer-events: none;
            /* Let clicks pass through if needed, but buttons need pointer-events auto */
            z-index: 95;
        }



        .shop-card:hover .unit-tooltip {
            z-index: 10000 !important;
            display: block;
        }

        .hp-bar-container {
            position: absolute;
            bottom: 5px;
            left: 0;
            width: 100%;
            height: 6px;
            background: #333;
            border: 1px solid #000;
            z-index: 20;
            top: auto;
        }

        .mana-bar-container {
            position: absolute;
            bottom: 1px;
            left: 0;
            width: 100%;
            height: 4px;
            background: #222;
            border: 1px solid #000;
            z-index: 20;
        }

        .hit-damage.crit {
            color: #ff3333;
            font-weight: 900;
            text-shadow: 0 0 5px red;
            font-size: 2rem !important;
        }

        .hit-damage.heal {
            color: #00ff00;
            text-shadow: 0 0 5px lime;
        }

        #augment-list-container {
            position: fixed;
            right: 10px;
            bottom: 180px;
            width: 180px;
            max-height: 250px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #7aa2f740;
            border-radius: 8px;
            padding: 8px;
            z-index: 80;
            backdrop-filter: blur(8px);
            overflow: visible;
        }

        .augment-icon {
            padding: 4px 8px;
            border-radius: 5px;
            font-size: 0.7rem;
            color: white;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid #555;
            cursor: pointer;
            position: relative;
            display: inline-block;
            margin: 2px;
        }

        .augment-tooltip {
            position: absolute;
            bottom: 100%;
            left: 0;
            background: rgba(20, 22, 35, 0.98);
            border: 1px solid #7aa2f7;
            border-radius: 8px;
            padding: 10px;
            min-width: 200px;
            max-width: 250px;
            z-index: 10000;
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.2s, visibility 0.2s;
            text-align: left;
            white-space: normal;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.5);
        }

        .augment-icon:hover .augment-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .augment-icon.silver {
            border-color: #c0c0c0;
        }

        .augment-icon.gold {
            border-color: #ffd700;
            color: #ffd700;
        }

        .augment-icon.prismatic {
            border-color: #ff9e64;
            color: #ff9e64;
            box-shadow: 0 0 5px #ff9e64;
        }

        .inventory-slot {
            width: 38px;
            height: 38px;
            background: rgba(36, 40, 59, 0.8);
            border: 1px dashed #414868;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
        }

        .inventory-slot.can-craft {
            border-color: #ffd700;
            box-shadow: 0 0 5px gold;
        }

        .item-icon {
            width: 32px;
            height: 32px;
            border-radius: 4px;
            background: #1a1b26;
            border: 1px solid #7aa2f7;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: #fff;
            position: relative;
        }

        /* ===== AUGMENT OVERLAY ===== */
        #augment-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 10000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .augment-title {
            font-size: 2rem;
            color: #ffd700;
            margin-bottom: 40px;
            text-shadow: 0 0 20px gold;
            font-weight: 900;
        }

        .augment-choices {
            display: flex;
            gap: 30px;
        }

        .augment-card {
            width: 220px;
            height: 320px;
            background: linear-gradient(180deg, #24283b, #1a1b26);
            border: 2px solid #414868;
            border-radius: 15px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .augment-card:hover {
            transform: translateY(-15px) scale(1.05);
            border-color: #7aa2f7;
            box-shadow: 0 0 30px #7aa2f740;
        }

        .augment-card.silver {
            border-color: #c0c0c0;
        }

        .augment-card.gold {
            border-color: #ffd700;
        }

        .augment-card.prismatic {
            border-color: #bb9af7;
            box-shadow: 0 0 20px #bb9af720;
        }

        .augment-name {
            font-weight: bold;
            font-size: 1.25rem;
            margin: 15px 0;
            color: #fff;
        }

        .augment-desc {
            font-size: 0.85rem;
            color: #aaa;
            line-height: 1.5;
        }

        @keyframes popUp {
            0% {
                opacity: 1;
                transform: translate(-50%, 0);
            }

            100% {
                opacity: 0;
                transform: translate(-50%, -50px);
            }
        }

        /* ===== TOAST ===== */
        #game-toast {
            position: fixed;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.85);
            color: #fff;
            padding: 12px 25px;
            border-radius: 10px;
            font-weight: bold;
            z-index: 2000;
            opacity: 0;
            transition: all 0.3s;
            pointer-events: none;
            border: 1px solid #7aa2f7;
        }

        #game-toast.visible {
            opacity: 1;
            top: 12%;
        }

        .row-label {
            position: absolute;
            left: -40px;
            top: 20px;
            font-size: 0.65rem;
            color: #565f89;
            font-weight: bold;
        }

        /* Streak Badge Styles */
        .streak-fire {
            color: #ff9e64;
            text-shadow: 0 0 5px #ff9e6440;
        }

        .streak-ice {
            color: #7aa2f7;
            text-shadow: 0 0 5px #7aa2f740;
        }

        .streak-info {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        /* Synergy List Carousel Styles */
        #synergy-list-container {
            position: fixed;
            left: 230px;
            top: 80px;
            width: 385px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #7aa2f740;
            border-radius: 12px;
            padding: 0;
            z-index: 80;
            height: 410px;
            backdrop-filter: blur(8px);
            /* box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5); removed */
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .synergy-list-header {
            font-weight: bold;
            padding: 10px 5px;
            color: #7aa2f7;
            border-bottom: 2px solid #7aa2f740;
            text-align: center;
            font-size: 0.85rem;
            background: rgba(122, 162, 247, 0.1);
        }

        #synergy-list-content {
            display: flex;
            overflow-x: auto;
            scroll-snap-type: x mandatory;
            flex: 1;
            padding-bottom: 0;
            scrollbar-width: none;
        }

        #synergy-list-content::-webkit-scrollbar {
            display: none;
        }

        /* Chrome/Safari */

        .synergy-card {
            min-width: 34%;
            scroll-snap-align: start;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            box-sizing: border-box;
        }

        .synergy-card-title {
            font-weight: bold;
            color: #c0caf5;
            font-size: 0.9rem;
            text-align: center;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }

        .synergy-tier-row {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .tier-header {
            font-size: 0.65rem;
            font-weight: bold;
            opacity: 0.8;
            margin-bottom: 2px;
        }

        .unit-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
        }

        .unit-chip {
            font-size: 0.7rem;
            padding: 2px 5px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            white-space: nowrap;
        }

        .carousel-nav {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-top: 1px solid #444;
            gap: 5px;
        }

        .carousel-nav button {
            flex: 1;
            padding: 5px !important;
            font-size: 0.7rem !important;
            background: rgba(122, 162, 247, 0.2);
            border: 1px solid #7aa2f740;
            color: #7aa2f7;
            border-radius: 4px;
            cursor: pointer;
        }

        .carousel-nav button:hover {
            background: rgba(122, 162, 247, 0.4);
            border-color: #7aa2f7;
        }

        .btn-mini-refresh {
            background: rgba(122, 162, 247, 0.2);
            border: 1px solid #7aa2f7;
            color: #7aa2f7;
            border-radius: 6px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 0.7rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-mini-refresh:hover {
            background: #7aa2f7;
            color: #1a1b26;
            box-shadow: 0 0 15px #7aa2f780;
        }

        #drop-table-container {
            box-shadow: none !important;
            border: none !important;
            background: rgba(0, 0, 0, 0.2) !important;
        }

        /* ===== RESPONSIVE STYLES ===== */
        @media (max-width: 1024px) {
            /* Mobile Layout Overrides */

            body {
                overflow-x: hidden;
            }

            .game-area {
                width: 100%;
                /* Scale board to fit screen instead of shrinking cells */
                transform-origin: top center;
                /* Use a safer scale calculation */
                transform: scale(min(1, calc(100vw / 520)));
                margin-bottom: -150px;
                /* Adjust spacing after scaling */
            }

            /* Hide Desktop Side Panels */
            #synergy-panel,
            #bot-synergy-panel,
            #item-guide-panel,
            #synergy-list-container {
                display: none;
            }

            /* Footer Layout */
            footer {
                padding: 10px 10px 20px 10px !important;
                /* Reset padding */
                width: 100%;
                background: linear-gradient(to top, #1a1b26, rgba(26, 27, 38, 0.8));
            }

            /* Mobile Navigation - Inside Footer */
            #mobile-nav {
                display: flex;
                width: 100%;
                justify-content: space-around;
                background: #111218;
                margin-top: 15px;
                padding: 12px 0;
                border-radius: 8px;
                border: 1px solid #333;
                position: relative;
                /* Static position in flow */
                z-index: 10;
            }

            #mobile-nav button {
                flex-direction: column;
                font-size: 0.75rem;
                gap: 4px;
                color: #889;
                padding: 0 10px;
                width: auto;
            }

            #mobile-nav button.active {
                color: #f7a049;
                text-shadow: 0 0 5px rgba(247, 160, 73, 0.5);
            }

            #mobile-nav button i {
                font-size: 1.4rem;
                margin-bottom: 2px;
            }

            /* Inventory Overlay logic */
            #inventory-container {
                display: none;
                /* Hidden by default */
                position: absolute;
                bottom: 80px;
                /* Above mobile nav roughly */
                left: 0;
                width: 100%;
                background: #1f2335;
                z-index: 100;
                border-top: 2px solid #5c4d3c;
                padding: 15px;
                gap: 8px;
                justify-content: center;
                /* Prevent stretching */
                grid-template-columns: repeat(auto-fit, 50px);
                max-height: 50vh;
                overflow-y: auto;
                box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.5);
            }

            #inventory-container.mobile-visible {
                display: grid !important;
                animation: slideUp 0.3s;
            }

            /* Make panels centered overlay */
            #synergy-panel.mobile-visible,
            #item-guide-panel.mobile-visible,
            #synergy-list-container.mobile-visible {
                display: flex !important;
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 90%;
                max-width: 400px;
                max-height: 80vh;
                background: #1a1b26;
                z-index: 9999;
                border: 2px solid #5c4d3c;
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
                border-radius: 8px;
            }

            @keyframes slideUp {
                from {
                    transform: translateY(20px);
                    opacity: 0;
                }

                to {
                    transform: translateY(0);
                    opacity: 1;
                }
            }
        }

        @media (max-width: 768px) {

            /* General Layout */
            body {
                overflow-x: hidden;
            }

            header {
                padding: 10px;
                flex-direction: column;
                gap: 10px;
            }

            .header-info {
                width: 100%;
                justify-content: space-between;
                font-size: 0.9rem;
            }

            .stage-badge,
            .gold-display,
            .health-bar {
                padding: 4px 10px;
                font-size: 0.9rem;
            }

            main {
                padding: 5px;
                width: 100%;
            }

            .game-area {
                width: 100%;
                padding: 2px;
                border: none;
                background: transparent;
            }

            /* Keep board fixed size, just center it */

            /* Unit Scaling */
            .unit {
                width: 90%;
                height: 90%;
                font-size: 0.5rem;
                border-width: 1px;
            }

            .unit .unit-bg-icon {
                font-size: 20px;
            }

            /* Shop & Bench */
            footer {
                padding: 5px;
            }

            .shop-container {
                transform: scale(0.85);
                transform-origin: bottom center;
                gap: 2px;
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                margin-top: 0;
            }

            .shop-card {
                width: 100px;
                padding: 4px;
            }

            .bench-container {
                gap: 4px;
                padding: 5px;
                margin: 2px 0;
            }

            .slot {
                width: 12vw;
                height: 12vw;
                max-width: 50px;
                max-height: 50px;
            }

            /* Controls */
            .controls {
                transform: scale(0.9);
                gap: 5px;
            }

            button {
                padding: 6px 10px;
                font-size: 0.75rem;
            }

            /* Panels - Hide or Reposition */
            #synergy-panel {
                display: none;
                /* Hide for now on mobile, too cluttered */
            }

            #bot-synergy-panel {
                display: none;
            }

            #item-guide-panel {
                right: 50%;
                transform: translateX(50%);
                top: 60px;
                width: 90%;
                height: 50vh;
                display: none;
                /* Initially hidden */
            }

            #inventory-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 220px;
                /* Above shop area */
                grid-template-columns: repeat(8, 1fr);
                gap: 2px;
                height: auto;
                padding: 5px;
                justify-items: center;
            }

            .inventory-slot {
                width: 100%;
                aspect-ratio: 1/1;
                height: auto;
            }

            #drop-table-container,
            #damage-overlay,
            #augment-list-container {
                display: none !important;
                /* Simplify UI for mobile */
            }

            #synergy-list-container {
                left: 50%;
                transform: translateX(-50%);
                width: 95%;
                top: 15%;
            }

            /* Sell Zone */
            #sell-zone {
                width: 60px;
                height: 60px;
                font-size: 0.7rem;
                bottom: 15rem;
            }

            /* Make sure tooltips don't overflow */
            .unit-tooltip {
                position: fixed;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                bottom: auto !important;
                width: 80vw;
                max-width: 300px;
                z-index: 9999;
            }
        }

        /* Mobile Navigation */
        #mobile-nav {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #1a1b26;
            border-top: 1px solid #444;
            display: flex;
            /* Always visible */
            justify-content: space-around;
            padding: 10px 0;
            z-index: 9000;
            padding-bottom: max(10px, env(safe-area-inset-bottom));
        }

        #mobile-nav button {
            background: transparent;
            border: none;
            color: #888;
            font-size: 0.7rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            box-shadow: none;
            padding: 0;
        }

        #mobile-nav button.active {
            color: #ffd700;
        }

        #mobile-nav button i {
            font-size: 1.2rem;
            margin-bottom: 2px;
        }

        /* Panel visibility toggles */
        .mobile-visible {
            display: block !important;
            z-index: 8000 !important;
            animation: fadeIn 0.2s;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px) translateX(50%);
            }

            to {
                opacity: 1;
                transform: translateY(0) translateX(50%);
            }
        }


        @media (max-width: 768px) {

            /* General Layout - Mobile Mode */
            body {
                overflow-x: hidden;
            }

            header {
                padding: 10px;
                flex-direction: column;
                gap: 5px;
            }

            .header-info {
                width: 100%;
                justify-content: space-between;
                font-size: 0.9rem;
            }

            .stage-badge,
            .gold-display,
            .health-bar {
                padding: 4px 10px;
                font-size: 0.9rem;
            }

            main {
                padding: 5px;
                width: 100%;
                /* Add padding bottom to avoid overlap with bottom nav */
                padding-bottom: 60px;
            }

            .game-area {
                width: 100%;
                padding: 2px;
                border: none;
                background: transparent;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            /* Keep board fixed size */
            .unit {
                width: 90%;
                height: 90%;
                font-size: 0.6rem;
                border-width: 1px;
            }

            .unit .unit-bg-icon {
                font-size: 20px;
            }

            /* Shop & Bench */
            footer {
                padding: 5px;
                padding-bottom: 70px;
                /* Space for nav */
            }

            .shop-container {
                transform: scale(1);
                gap: 4px;
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
                margin-top: 5px;
                height: auto;
            }

            .shop-card {
                width: 18%;
                /* Fit approx 5 cards */
                min-width: 60px;
                max-width: 100px;
                padding: 4px;
                font-size: 0.8rem;
            }

            /* Hide description/traits on small shop cards if needed, for better fit */
            .shop-card .unit-tooltip {
                display: none !important;
                /* Tooltip logic handles click/hover, but simplify CSS hover */
            }

            .bench-container {
                width: 100%;
                justify-content: center;
                gap: 4px;
                padding: 5px;
                margin: 2px 0;
            }

            .slot {
                width: 12vw;
                height: 12vw;
                max-width: 50px;
                max-height: 50px;
            }

            /* Controls */
            .controls {
                transform: scale(1);
                gap: 10px;
                width: 100%;
                justify-content: center;
                flex-wrap: wrap;
            }

            button {
                padding: 8px 16px;
                font-size: 0.8rem;
            }

            /* Panels - Hide or Reposition */
            #synergy-panel,
            #bot-synergy-panel {
                display: none;
            }

            #item-guide-panel {
                right: 50%;
                transform: translateX(50%);
                top: 10%;
                width: 90%;
                height: 60vh;
                display: none;
                z-index: 9000;
                background: #1a1b26;
                /* Solid background */
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
                border: 2px solid #5c4d3c;
            }

            #inventory-container {
                width: 90%;
                left: 50%;
                transform: translateX(-50%);
                top: auto;
                bottom: 250px;
                grid-template-columns: repeat(8, 1fr);
                gap: 4px;
                height: auto;
                padding: 10px;
                justify-items: center;
                display: none;
                z-index: 9000;
                background: rgba(26, 27, 38, 0.95);
            }

            .inventory-slot {
                width: 100%;
                aspect-ratio: 1/1;
                height: auto;
            }

            #drop-table-container,
            #augment-list-container {
                display: none !important;
            }

            #synergy-list-container {
                display: none;
                /* Hide by default on mobile/tablet */
                position: fixed;
                left: 50%;
                transform: translateX(-50%);
                width: 95%;
                top: 15%;
                background: #1a1b26;
                z-index: 9000;
                border: 2px solid #5c4d3c;
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            }

            #synergy-list-container.mobile-visible {
                display: flex !important;
            }

            /* Sell Zone */
            #sell-zone {
                bottom: 80px;
                width: 70px;
                height: 70px;
            }

            /* Tooltips */
            .unit-tooltip {
                position: fixed;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) !important;
                bottom: auto !important;
                width: 80vw;
                max-width: 300px;
                z-index: 10000;
                background: rgba(30, 30, 40, 0.98);
            }

            /* Mobile Navigation */
            #mobile-nav {
                display: flex;
            }

            /* Panel visibility toggles - Improved visibility */
            .mobile-visible {
                display: block !important;
                /* For inventory - it is grid usually but block is fine for container if styled */
                display: flex !important;
                /* Some might need flex */
                z-index: 9500 !important;
                animation: fadeIn 0.2s;
            }

            /* Specific fix for Inventory grid when visible */
            #inventory-container.mobile-visible {
                display: grid !important;
            }

            /* Synergy Panel as Mobile Overlay */
            #synergy-panel.mobile-visible {
                position: fixed;
                top: 10%;
                left: 50%;
                transform: translateX(-50%);
                width: 90%;
                max-height: 70vh;
                overflow-y: auto;
                background: #1a1b26;
                padding: 15px;
                border: 2px solid #5c4d3c;
                border-radius: 8px;
                box-shadow: 0 0 50px rgba(0, 0, 0, 0.8);
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <header>
            <div class="header-info">
                <button id="btn-mini-refresh" class="btn-mini-refresh" title="UI"> </button>
                <div class="stage-badge" id="stage-display">Stage 1-1</div>
                <div class="gold-display" id="player-gold">Gold: 5</div>
                <div id="player-streak" class="streak-info" style="min-width:80px;"></div>
            </div>
            <div class="header-info">
                <span class="health-bar" id="player-health">: 100</span>
                <span style="color:#8c7b64; margin: 0 10px; font-family:serif; font-style:italic;">VS</span>
                <span class="health-bar" id="opponent-health">: 100</span>
                <span id="bot-info"
                    style="font-size:0.85rem; color:#ffd700; margin-left:10px; background:rgba(0,0,0,0.3); padding:2px 8px; border-radius:4px; border:1px solid #c5a059;">Lv1
                    | 5G</span>
                <div id="bot-streak" class="streak-info" style="margin-left:10px;min-width:80px;"></div>
            </div>
        </header>

        <main>
            <div id="drop-table-container"></div>
            <div id="augment-list-container"></div>
            <div id="synergy-list-container">
                <div class="synergy-list-header"></div>
                <div id="synergy-list-content"></div>
                <div class="carousel-nav">
                    <button id="btn-syn-prev"> </button>
                    <button id="btn-syn-next"> </button>
                </div>
            </div>
            <div class="game-area">
                <div class="bot-area">
                    <div class="board" id="opponent-board"></div>
                </div>
                <div class="player-area">
                    <div class="board" id="player-board"></div>
                </div>
            </div>
            <div id="synergy-panel"></div>
            <div id="bot-synergy-panel"></div>
        </main>

        <!-- Inventory Section -->

        <!-- Unit Detail Box: Fixed position, high z-index (2000), Left of Item Guide -->
        <div id="unit-detail-box"
            style="display:none;position:fixed;top:120px;right:180px;width:240px;z-index:2000;background:#2b2520;border:2px solid #c5a059;border-radius:4px;padding:10px;pointer-events:none;color:#d4c5a3;font-family:'Times New Roman',serif;box-shadow:0 5px 20px rgba(0,0,0,0.6);">
        </div>

        <!-- Item Guide Panel -->
        <div id="item-guide-panel">
            <div class="guide-tabs">
                <div class="guide-tab active" onclick="switchGuideTab('recommended')"></div>
                <div class="guide-tab" onclick="switchGuideTab('recipes')"></div>
            </div>
            <div class="guide-content" id="guide-content-recommended" style="display:block;">
                <p style="color:#a09585;font-size:0.75rem;"></p>
            </div>
            <div class="guide-content" id="guide-content-recipes" style="display:none;"></div>
        </div>

        <div id="inventory-container"></div>
        <footer
            style="display:flex; flex-direction:column; align-items:center; padding:10px; position:relative; z-index:500;">
            <div style="display:flex; align-items:center; gap:20px; margin-bottom: 0;">
                <div class="controls">
                    <button id="btn-buy-xp"> (4G)</button>
                    <span id="level-info" style="font-weight:bold; font-size:0.8rem; color:#ffd700;">Lv1 (0/2)</span>
                </div>
                <div class="bench-container" id="player-bench"></div>
                <div class="controls">
                    <button id="btn-refresh"> (2G)</button>
                    <button id="btn-start"></button>
                </div>
            </div>
            <div class="shop-container" id="shop"></div>

            <!-- Mobile Navigation moved inside footer -->
            <div id="mobile-nav" style="display:none;">
                <button onclick="togglePanel('synergy-panel', this)"><i class="ra ra-scroll-unfurled"></i></button>
                <button onclick="togglePanel('synergy-list-container', this)"><i class="ra ra-book"></i></button>
                <button onclick="togglePanel('inventory-container', this)"><i class="ra ra-backpack"></i></button>
                <button onclick="togglePanel('item-guide-panel', this)"><i class="ra ra-sword"></i></button>
            </div>
        </footer>
    </div>

    <!-- Augment Overlay -->
    <div id="augment-overlay">
        <div class="augment-title">CHOOSE YOUR AUGMENT</div>
        <div class="augment-choices" id="augment-list"></div>

        <div id="sell-zone"></div>

        <div id="game-toast"></div>

        <script>
            // ===== ITEM DATA =====
            const BASE_ITEMS = {
                1: { name: '', stat: 'AD+10', stats: { ad: 10 }, icon: 'ra ra-sword' },
                2: { name: '', stat: '+15%', stats: { as: 0.15 }, icon: 'ra ra-crossbow' },
                3: { name: '', stat: 'AP+10', stats: { ap: 10 }, icon: 'ra ra-crystal-cluster' },
                4: { name: '', stat: '+15', stats: { mana: 15 }, icon: 'ra ra-water-drop' },
                5: { name: '', stat: '+20', stats: { armor: 20 }, icon: 'ra ra-vest' },
                6: { name: '', stat: '+20', stats: { mr: 20 }, icon: 'ra ra-hood' },
                7: { name: '', stat: 'HP+150', stats: { hp: 150 }, icon: 'ra ra-heart-bottle' },
                8: { name: '', stat: '+10%', stats: { crit: 10 }, icon: 'ra ra-hand' },
                9: { name: '', stat: '???', stats: {}, icon: 'ra ra-shovel' },
                10: { name: '', stat: '???', stats: {}, icon: 'ra ra-trophy' }
            };

            const ITEM_RECIPES = {
                // Sword (1 - Longsword)
                '1-1': { name: '', desc: 'AD+50', stats: { ad: 50 }, icon: 'ra ra-broadsword', type: 'ad' },
                '1-2': { name: '', desc: 'HP1600+25%', stats: { ad: 20, as: 0.1 }, icon: 'ra ra-monster-skull', effect: 'giant_slayer', type: 'ad' },
                '1-3': { name: '', desc: '20%', stats: { ad: 15, ap: 15, vamp: 0.2 }, icon: 'ra ra-crystal-wand', type: 'hybrid' },
                '1-4': { name: '', desc: '5', stats: { ad: 20, mana: 15 }, icon: 'ra ra-spear-head', effect: 'shojin', type: 'mana' },
                '1-5': { name: '', desc: 'HP60%', stats: { ad: 30, armor: 20 }, icon: 'ra ra-plain-dagger', effect: 'edge_of_night', type: 'def' },
                '1-6': { name: '', desc: '20%/HP', stats: { ad: 20, mr: 20, vamp: 0.2 }, icon: 'ra ra-dripping-sword', effect: 'bloodthirster', type: 'ad' },
                '1-7': { name: '', desc: 'HPHP/AD', stats: { hp: 200, ad: 20 }, icon: 'ra ra-kettlebell', effect: 'sterak', type: 'tank' },
                '1-8': { name: '', desc: '', stats: { ad: 35, crit: 0.2 }, icon: 'ra ra-lightning-sword', effect: 'ie', type: 'crit' },
                '1-9': { name: '', traits: ['Warrior'], icon: 'ra ra-axe', type: 'trait' },

                // Bow (2 - Crossbow)
                '2-2': { name: '', desc: '+1/+30%', stats: { as: 0.4 }, icon: 'ra ra-target-arrows', effect: 'rfc', type: 'as' },
                '2-3': { name: '', desc: '+5%', stats: { as: 0.15, ap: 10 }, icon: 'ra ra-feather-wing', effect: 'guinsoo', type: 'as' },
                '2-4': { name: '', desc: '3', stats: { as: 0.15, mana: 15 }, icon: 'ra ra-lightning-storm', effect: 'statikk', type: 'as' },
                '2-5': { name: '', desc: '', stats: { as: 0.1, armor: 20 }, icon: 'ra ra-muscle-up', effect: 'titan', type: 'tank' },
                '2-6': { name: '', desc: '50%', stats: { as: 0.2, mr: 20 }, icon: 'ra ra-arrow-cluster', effect: 'runaan', type: 'ad' },
                '2-7': { name: '', desc: 'UP', stats: { as: 0.1, hp: 150 }, icon: 'ra ra-insect-jaws', effect: 'nashor', type: 'as' },
                '2-8': { name: '', desc: '50%', stats: { as: 0.15, crit: 0.15 }, icon: 'ra ra-cracked-shield', effect: 'last_whisper', type: 'ad' },
                '2-9': { name: '', traits: ['Sniper'], icon: 'ra ra-musket', type: 'trait' },

                // Rod (3 - Staff)
                '3-3': { name: '', desc: 'AP+70', stats: { ap: 70 }, icon: 'ra ra-crystal-ball', type: 'ap' },
                '3-4': { name: '', desc: '5AP+20', stats: { ap: 20, mana: 15 }, icon: 'ra ra-angel-wings', effect: 'archangel', type: 'ap' },
                '3-5': { name: '', desc: '', stats: { ap: 20, armor: 20 }, icon: 'ra ra-crown', effect: 'crownguard', type: 'tank' },
                '3-6': { name: '', desc: '50%', stats: { ap: 10, mr: 20 }, icon: 'ra ra-lightning', effect: 'ionic', type: 'ap' },
                '3-7': { name: '', desc: '', stats: { ap: 25, hp: 150 }, icon: 'ra ra-burning-book', effect: 'morello', type: 'ap' },
                '3-8': { name: '', desc: '', stats: { ap: 30, crit: 0.2 }, icon: 'ra ra-gem', effect: 'jg', type: 'ap' },
                '3-9': { name: '', traits: ['Mage'], icon: 'ra ra-fairy-wand', type: 'trait' },

                // Tear (4 - Holy Water)
                '4-4': { name: '', desc: '-10/', stats: { mana: 40 }, icon: 'ra ra-potion', effect: 'blue_buff', type: 'mana' },
                '4-5': { name: '', desc: '+30', stats: { mana: 30, armor: 20 }, icon: 'ra ra-round-shield', effect: 'protector', type: 'tank' },
                '4-6': { name: '', desc: '/', stats: { mana: 15, mr: 20 }, icon: 'ra ra-knight-helmet', effect: 'adaptive', type: 'tank' },
                '4-7': { name: '', desc: '', stats: { mana: 15, hp: 150 }, icon: 'ra ra-health', effect: 'redemption', type: 'supp' },
                '4-8': { name: '', desc: 'ADAP+15/', stats: { mana: 15, crit: 0.15 }, icon: 'ra ra-gavel', effect: 'hoj', type: 'hybrid' },
                '4-9': { name: '', traits: ['Scholar'], icon: 'ra ra-book', type: 'trait' },

                // Vest (5 - Chainmail)
                '5-5': { name: '', desc: '/', stats: { armor: 60 }, icon: 'ra ra-thorny-vine', effect: 'bramble', type: 'tank' },
                '5-6': { name: '', desc: '1UP', stats: { armor: 30, mr: 30 }, icon: 'ra ra-heavy-shield', effect: 'gargoyle', type: 'tank' },
                '5-7': { name: '', desc: '', stats: { armor: 20, hp: 200 }, icon: 'ra ra-sun', effect: 'sunfire', type: 'tank' },
                '5-8': { name: '', desc: '', stats: { armor: 20, crit: 0.1 }, icon: 'ra ra-hearts', effect: 'steadfast', type: 'tank' },
                '5-9': { name: '', traits: ['Tank'], icon: 'ra ra-tower', type: 'trait' },

                // Cloak (6 - Robe)
                '6-6': { name: '', desc: 'MR+60/', stats: { mr: 60 }, icon: 'ra ra-dragon-wing', effect: 'dragon_claw', type: 'tank' },
                '6-7': { name: '', desc: '', stats: { mr: 20, hp: 150 }, icon: 'ra ra-cloak-and-dagger', effect: 'evenshroud', type: 'tank' },
                '6-8': { name: '', desc: 'CC', stats: { mr: 20, as: 0.2 }, icon: 'ra ra-bottle-vapors', effect: 'qss', type: 'def' },
                '6-9': { name: '', traits: ['Enchanter'], icon: 'ra ra-fairy-wand', type: 'trait' },

                // Belt (7 - Knight's Belt)
                '7-7': { name: '', desc: 'HP+600', stats: { hp: 600 }, icon: 'ra ra-health-increase', type: 'tank' },
                '7-8': { name: '', desc: '+25%', stats: { hp: 150, crit: 0.2 }, icon: 'ra ra-hammer', effect: 'guardbreaker', type: 'ad' },
                '7-9': { name: '', traits: ['Beast'], icon: 'ra ra-pawprint', type: 'trait' },

                // Glove (8 - Iron Gauntlets)
                '8-8': { name: '', desc: '2', stats: { crit: 20 }, icon: 'ra ra-clovers-card', effect: 'thief', type: 'special' },
                '8-9': { name: '', traits: ['Assassin'], icon: 'ra ra-plain-dagger', type: 'trait', stats: { crit: 10 } },

                // Spatula (9 - Royal Crest)
                '9-9': { name: '', desc: '+1', stats: {}, effect: 'fon', icon: 'ra ra-crown', type: 'special' },

                // Pan (10 - Golden Chalice)
                '10-10': { name: '', traits: ['Void'], icon: 'ra ra-eye-monster', type: 'trait', stats: {} },

                // Emblems
                '1-10': { name: '', traits: ['Pyro'], icon: 'ra ra-fire', type: 'trait' },
                '2-10': { name: '', traits: ['Frost'], icon: 'ra ra-snowflake', type: 'trait' },
                '3-10': { name: '', traits: ['Cosmic'], icon: 'ra ra-burning-meteor', type: 'trait' },
                '4-10': { name: '', traits: ['Epoch'], icon: 'ra ra-hourglass', type: 'trait' },
                '5-10': { name: '', traits: ['Machine'], icon: 'ra ra-gear-hammer', type: 'trait' },
                '6-10': { name: '', traits: ['Light'], icon: 'ra ra-sun-symbol', type: 'trait' },
                '7-10': { name: '', traits: ['Cyber'], icon: 'ra ra-battery-100', type: 'trait' },
                '8-10': { name: '', traits: ['Dark'], icon: 'ra ra-skull', type: 'trait' },
                '9-10': { name: '', traits: ['Dragon'], icon: 'ra ra-dragon', type: 'trait' }
            };

            const ROLE_RECOMMENDATIONS = {
                'tank': ['5-5', '6-6', '7-7', '5-6', '5-7', '4-5'],
                'mage': ['4-4', '3-8', '3-3', '1-4', '3-4', '3-7'],
                'fighter': ['1-6', '2-5', '1-8', '1-7', '4-8', '6-8'],
                'assassin': ['1-8', '4-8', '1-5', '1-2', '2-8', '1-1'],
                'ranger': ['2-3', '1-8', '2-8', '1-2', '2-2', '1-6'],
                'enchanter': ['1-4', '3-4', '2-3', '4-7', '1-3', '4-4']
            };

            const SYNERGY_DATA = {
                // Origins
                'Epoch': { name: '', levels: [{ count: 2, effect: '+4', type: 'active-bronze' }, { count: 3, effect: '+10', type: 'active-gold' }] },
                'Frost': { name: '', levels: [{ count: 2, effect: '20%(1)', type: 'active-bronze' }, { count: 4, effect: '40%(1.5)', type: 'active-silver' }, { count: 6, effect: '(2)', type: 'active-gold' }] },
                'Pyro': { name: '', levels: [{ count: 2, effect: ':30', type: 'active-bronze' }, { count: 3, effect: ':60', type: 'active-silver' }, { count: 5, effect: ':120', type: 'active-gold' }] },
                'Cyber': { name: '', levels: [{ count: 2, effect: 'HP+200', type: 'active-bronze' }, { count: 4, effect: 'HP+400', type: 'active-silver' }, { count: 6, effect: 'HP+800/AR+30', type: 'active-gold' }] },
                'Void': { name: '', levels: [{ count: 2, effect: 'AR/MR-15%', type: 'active-bronze' }, { count: 4, effect: 'AR/MR-30%', type: 'active-silver' }, { count: 6, effect: 'AR/MR-50%/10%', type: 'active-gold' }] },
                'Dark': { name: '', levels: [{ count: 2, effect: '15%', type: 'active-bronze' }, { count: 4, effect: '30%', type: 'active-silver' }, { count: 6, effect: '50%', type: 'active-gold' }] },
                'Light': { name: '', levels: [{ count: 2, effect: 'HP200', type: 'active-bronze' }, { count: 4, effect: 'HP400', type: 'active-silver' }, { count: 6, effect: 'HP600+', type: 'active-gold' }, { count: 8, effect: ':', type: 'active-prismatic' }] },
                'Machine': { name: '', levels: [{ count: 2, effect: 'AR+20', type: 'active-bronze' }, { count: 4, effect: ':+30%', type: 'active-silver' }, { count: 6, effect: ':+60%', type: 'active-gold' }] },
                'Beast': { name: '', levels: [{ count: 2, effect: '+15%', type: 'active-bronze' }, { count: 4, effect: '+30%', type: 'active-silver' }, { count: 6, effect: '+50%/UP', type: 'active-gold' }] },
                'Dragon': { name: '', levels: [{ count: 1, effect: ':AP+50', type: 'active-silver' }, { count: 2, effect: ':', type: 'active-gold' }] },
                // Classes
                'Tank': { name: '', levels: [{ count: 2, effect: 'HP+200', type: 'active-bronze' }, { count: 4, effect: 'HP+450/AR+20', type: 'active-silver' }, { count: 6, effect: 'HP+800/AR+40/15%', type: 'active-gold' }] },
                'Warrior': { name: '', levels: [{ count: 2, effect: 'AD+15%', type: 'active-bronze' }, { count: 4, effect: 'AD+35%', type: 'active-silver' }, { count: 6, effect: 'AD+60%', type: 'active-gold' }, { count: 8, effect: 'AD+100%/', type: 'active-prismatic' }] },
                'Mage': { name: '', levels: [{ count: 2, effect: 'AP+20', type: 'active-bronze' }, { count: 4, effect: 'AP+50/2', type: 'active-silver' }, { count: 6, effect: 'AP+100/3', type: 'active-gold' }] },
                'Assassin': { name: '', levels: [{ count: 2, effect: '+15%', type: 'active-bronze' }, { count: 4, effect: '+30%/+25%', type: 'active-silver' }, { count: 6, effect: '+50%/+50%', type: 'active-gold' }, { count: 8, effect: '/+100%', type: 'active-prismatic' }] },
                'Sniper': { name: '', levels: [{ count: 2, effect: '+1', type: 'active-bronze' }, { count: 4, effect: '+2/AD+5%', type: 'active-silver' }, { count: 6, effect: '+3/AD+10%', type: 'active-gold' }] },
                'Enchanter': { name: '', levels: [{ count: 2, effect: '/+20%', type: 'active-bronze' }, { count: 4, effect: 'MR+30/+40%', type: 'active-silver' }, { count: 6, effect: 'MR+50/', type: 'active-gold' }] },
                'Scholar': { name: '', levels: [{ count: 2, effect: '+5', type: 'active-bronze' }, { count: 4, effect: '+10', type: 'active-silver' }, { count: 6, effect: '+20', type: 'active-gold' }] },
                // Special - 11 level
                'Cosmic': { name: '', levels: [{ count: 2, effect: 'HP+100/AR+5', type: 'active-bronze' }, { count: 3, effect: 'HP+200/AR+10', type: 'active-silver' }, { count: 4, effect: 'HP+300/AR+15', type: 'active-silver' }, { count: 5, effect: 'HP+400/AR+20', type: 'active-silver' }, { count: 6, effect: 'HP+500/AR+25', type: 'active-gold' }, { count: 7, effect: 'HP+600/AR+30', type: 'active-gold' }, { count: 8, effect: 'HP+800/AR+40', type: 'active-gold' }, { count: 9, effect: 'HP+1000/AR+50', type: 'active-prismatic' }, { count: 10, effect: 'HP+1500/AR+70', type: 'active-prismatic' }, { count: 11, effect: 'HP+2000/AR+100/30%', type: 'active-prismatic' }] }
            };

            const AUGMENT_DATA = [
                // --- SILVER ---
                { id: 's_hp1', name: ' I', tier: 'silver', desc: 'HP+150', effect: 'team_hp', value: 150 },
                { id: 's_ad1', name: ' I', tier: 'silver', desc: 'AD+10%', effect: 'team_ad', value: 10 },
                { id: 's_ap1', name: '', tier: 'silver', desc: 'AP+10', effect: 'team_ap', value: 10 },
                { id: 's_as1', name: '', tier: 'silver', desc: 'AS+10%', effect: 'team_as', value: 10 },
                { id: 's_ar1', name: '', tier: 'silver', desc: 'AR+15', effect: 'team_armor', value: 15 },
                { id: 's_mr1', name: '', tier: 'silver', desc: 'MR+15', effect: 'team_mr', value: 15 },
                { id: 's_kill_heal', name: '', tier: 'silver', desc: '300', effect: 'on_kill_heal', value: 300 },
                { id: 's_comp', name: '', tier: 'silver', desc: '1', effect: 'gain_component', value: 1 },
                { id: 's_rich', name: '', tier: 'silver', desc: '8G', effect: 'gain_gold', value: 8 },
                { id: 's_xp', name: '', tier: 'silver', desc: '8XP', effect: 'gain_xp', value: 8 },
                { id: 's_roll', name: '', tier: 'silver', desc: '1', effect: 'free_reroll', value: 1 },
                { id: 's_bench', name: '', tier: 'silver', desc: '1AD/AP+5', effect: 'bench_power', value: 5 },
                { id: 's_early', name: '', tier: 'silver', desc: '230%', effect: 'start_reduce', value: 30 },
                { id: 's_thrill', name: '', tier: 'silver', desc: 'HP50%AD+20%', effect: 'low_hp_ad', value: 20 },
                { id: 's_dummy', name: '', tier: 'silver', desc: '+200', effect: 'start_shield', value: 200 },
                { id: 's_cyber', name: '', tier: 'silver', desc: 'HP+200', effect: 'item_hp', value: 200 },
                { id: 's_mage', name: '', tier: 'silver', desc: '+1', effect: 'trait_mage', value: 1 },
                { id: 's_tank', name: '', tier: 'silver', desc: '+1', effect: 'trait_tank', value: 1 },
                { id: 's_scope', name: '', tier: 'silver', desc: '+1', effect: 'back_range', value: 1 },
                { id: 's_bank', name: '', tier: 'silver', desc: '7', effect: 'max_interest', value: 7 },
                { id: 's_knife', name: ' I', tier: 'silver', desc: 'AD+15%', effect: 'front_ad', value: 15 },
                { id: 's_battle', name: ' I', tier: 'silver', desc: 'AP+15', effect: 'front_ap', value: 15 },
                { id: 's_feather', name: ' I', tier: 'silver', desc: '1-2AS+20%', effect: 'low_cost_as', value: 20 },
                { id: 's_cele', name: ' I', tier: 'silver', desc: '(300)', effect: 'overheal', value: 300 },
                { id: 's_wind', name: ' I', tier: 'silver', desc: '10HP40%', effect: 'second_wind', value: 40 },
                { id: 's_prep', name: ' I', tier: 'silver', desc: 'HP10%', effect: 'team_start_shield', value: 10 },
                { id: 's_exile', name: ' I', tier: 'silver', desc: '30%', effect: 'exile_shield', value: 30 },
                { id: 's_windfall', name: '', tier: 'silver', desc: '20G1', effect: 'immediate_rich', value: 0 },
                { id: 's_tiny', name: '', tier: 'silver', desc: 'HP+30', effect: 'player_hp', value: 30 },
                { id: 's_pandora', name: '', tier: 'silver', desc: '', effect: 'pandora', value: 1 },

                // --- GOLD ---
                { id: 'g_hp2', name: ' II', tier: 'gold', desc: 'HP+300', effect: 'team_hp', value: 300 },
                { id: 'g_ad2', name: ' II', tier: 'gold', desc: 'AD+15%', effect: 'team_ad', value: 15 },
                { id: 'g_ap2', name: '', tier: 'gold', desc: 'AP+20', effect: 'team_ap', value: 20 },
                { id: 'g_as2', name: '', tier: 'gold', desc: 'AS+20%', effect: 'team_as', value: 20 },
                { id: 'g_ar2', name: '', tier: 'gold', desc: 'AR+30', effect: 'team_armor', value: 30 },
                { id: 'g_mr2', name: '', tier: 'gold', desc: 'MR+30', effect: 'team_mr', value: 30 },
                { id: 'g_sun', name: '', tier: 'gold', desc: '10%', effect: 'start_burn', value: 10 },
                { id: 'g_thief', name: '', tier: 'gold', desc: '', effect: 'gain_item_thief', value: 1 },
                { id: 'g_rich', name: '', tier: 'gold', desc: '20G', effect: 'gain_gold', value: 20 },
                { id: 'g_xp', name: '', tier: 'gold', desc: '24XP', effect: 'gain_xp', value: 24 },
                { id: 'g_shop', name: '', tier: 'gold', desc: 'Tier4UP', effect: 'shop_tier4', value: 10 },
                { id: 'g_orb', name: '', tier: 'gold', desc: '400', effect: 'kill_heal_ally', value: 400 },
                { id: 'g_ascend', name: '', tier: 'gold', desc: '15+50%', effect: 'ascension', value: 50 },
                { id: 'g_united', name: '', tier: 'gold', desc: 'x3AD/AP', effect: 'synergy_stats', value: 3 },
                { id: 'g_march', name: '', tier: 'gold', desc: 'HP+100 AD+5', effect: 'march', value: 100 },
                { id: 'g_implant', name: '', tier: 'gold', desc: 'HP+300', effect: 'item_buff_2', value: 1 },
                { id: 'g_mage_c', name: '', tier: 'gold', desc: '', effect: 'gain_item_mage', value: 1 },
                { id: 'g_warr_c', name: '', tier: 'gold', desc: '', effect: 'gain_item_warrior', value: 1 },
                { id: 'g_health', name: '', tier: 'gold', desc: '2HP+250', effect: 'low_cost_hp', value: 250 },
                { id: 'g_meta', name: '', tier: 'gold', desc: 'HP2', effect: 'player_regen', value: 2 },
                { id: 'g_knife', name: ' II', tier: 'gold', desc: 'AD+30%', effect: 'front_ad', value: 30 },
                { id: 'g_battle', name: ' II', tier: 'gold', desc: 'AP+30', effect: 'front_ap', value: 30 },
                { id: 'g_feather', name: ' II', tier: 'gold', desc: '1-2AS+40%', effect: 'low_cost_as', value: 40 },
                { id: 'g_cele', name: ' II', tier: 'gold', desc: '(600)', effect: 'overheal', value: 600 },
                { id: 'g_wind', name: ' II', tier: 'gold', desc: '10HP60%', effect: 'second_wind', value: 60 },
                { id: 'g_prep', name: ' II', tier: 'gold', desc: 'AD/AP+4/R', effect: 'bench_stack', value: 4 },
                { id: 'g_exile', name: ' II', tier: 'gold', desc: '50%', effect: 'exile_shield', value: 50 },
                { id: 'g_richer', name: '', tier: 'gold', desc: '7 / +15G', effect: 'eco_combo', value: 7 },
                { id: 'g_comps', name: '', tier: 'gold', desc: '3', effect: 'gain_component_3', value: 3 },
                { id: 'g_last', name: '', tier: 'gold', desc: '', effect: 'last_stand', value: 1 },
                { id: 'g_dummy', name: ' II', tier: 'gold', desc: '+450', effect: 'start_shield', value: 450 },

                // --- PRISMATIC ---
                { id: 'p_hp3', name: ' III', tier: 'prismatic', desc: 'HP+500', effect: 'team_hp', value: 500 },
                { id: 'p_size', name: '', tier: 'prismatic', desc: '+1', effect: 'team_size', value: 1 },
                { id: 'p_wind', name: '', tier: 'prismatic', desc: '40G', effect: 'gain_gold', value: 40 },
                { id: 'p_lvl', name: '', tier: 'prismatic', desc: 'LvUP', effect: 'gain_level', value: 1 },
                { id: 'p_curse', name: '', tier: 'prismatic', desc: '+2 2', effect: 'cursed_size', value: 2 },
                { id: 'p_ticket', name: '', tier: 'prismatic', desc: '40%', effect: 'reroll_chance', value: 40 },
                { id: 'p_gloves', name: '', tier: 'prismatic', desc: '2', effect: 'gain_item_thief_2', value: 2 },
                { id: 'p_binary', name: '', tier: 'prismatic', desc: '23', effect: 'binary_airdrop', value: 1 },
                { id: 'p_clone', name: '', tier: 'prismatic', desc: '', effect: 'clone_best', value: 1 },
                { id: 'p_diff', name: '', tier: 'prismatic', desc: 'HP+500', effect: 'no_trait_buff', value: 500 },
                { id: 'p_knife', name: ' III', tier: 'prismatic', desc: 'AD+50%', effect: 'front_ad', value: 50 },
                { id: 'p_battle', name: ' III', tier: 'prismatic', desc: 'AP+50', effect: 'front_ap', value: 50 },
                { id: 'p_feather', name: ' III', tier: 'prismatic', desc: '1-2AS+70%', effect: 'low_cost_as', value: 70 },
                { id: 'p_cele', name: ' III', tier: 'prismatic', desc: '(1200)', effect: 'overheal', value: 1200 },
                { id: 'p_wind3', name: ' III', tier: 'prismatic', desc: '10', effect: 'second_wind', value: 100 },
                { id: 'p_prep', name: ' III', tier: 'prismatic', desc: 'AD/AP+8/R', effect: 'bench_stack', value: 8 },
                { id: 'p_exile', name: ' III', tier: 'prismatic', desc: '80%', effect: 'exile_shield', value: 80 },
                { id: 'p_hedge', name: '', tier: 'prismatic', desc: '10 / +30G', effect: 'eco_combo', value: 10 },
                { id: 'p_items', name: '', tier: 'prismatic', desc: '2', effect: 'gain_completed_2', value: 2 },
                { id: 'p_titan', name: '', tier: 'prismatic', desc: 'HP+60', effect: 'player_hp_huge', value: 60 }
            ];

            const XP_TABLE = { 1: 2, 2: 2, 3: 6, 4: 10, 5: 20, 6: 36, 7: 56, 8: 80, 9: 100, 10: 120, 11: 999 };
            const DROP_RATES = {
                1: [100, 0, 0, 0, 0], 2: [100, 0, 0, 0, 0], 3: [75, 25, 0, 0, 0], 4: [55, 30, 15, 0, 0],
                5: [45, 33, 20, 2, 0], 6: [35, 35, 25, 5, 0], 7: [22, 35, 30, 12, 1], 8: [15, 25, 35, 20, 5],
                9: [10, 15, 30, 30, 15], 10: [5, 10, 20, 40, 25], 11: [1, 2, 12, 35, 50]
            };

            const UNIT_DATA = {
                // -- TIER 1 --
                'Zenith': { displayName: '', cost: 1, tier: 1, traits: ['Light', 'Tank', 'Cosmic'], icon: 'ra ra-sun', type: 'tank', stats: { hp: 650, ad: 50, range: 1, armor: 40, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Lumina': { displayName: '', cost: 1, tier: 1, traits: ['Light', 'Mage', 'Cosmic'], icon: 'ra ra-fairy-wand', type: 'mage', stats: { hp: 450, ad: 40, range: 4, armor: 20, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Volca': { displayName: '', cost: 1, tier: 1, traits: ['Pyro', 'Warrior'], icon: 'ra ra-fire', type: 'fighter', stats: { hp: 700, ad: 55, range: 1, armor: 35, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Shiro': { displayName: '', cost: 1, tier: 1, traits: ['Frost', 'Assassin'], icon: 'ra ra-ice-cube', type: 'assassin', stats: { hp: 500, ad: 60, range: 1, armor: 25, mana: 50, crit: 10 }, skill: { name: '', desc: '' } },
                'Rune': { displayName: '', cost: 1, tier: 1, traits: ['Cyber', 'Scholar'], icon: 'ra ra-scroll-unfurled', type: 'enchanter', stats: { hp: 550, ad: 45, range: 3, armor: 25, mana: 120, crit: 10 }, skill: { name: '', desc: '' } },
                'Voida': { displayName: '', cost: 1, tier: 1, traits: ['Void', 'Assassin'], icon: 'ra ra-plain-dagger', type: 'assassin', stats: { hp: 500, ad: 65, range: 1, armor: 20, mana: 40, crit: 10 }, skill: { name: '', desc: '' } },
                'Aero': { displayName: '', cost: 1, tier: 1, traits: ['Cyber', 'Sniper'], icon: 'ra ra-feather-wing', type: 'ranger', stats: { hp: 450, ad: 50, range: 4, armor: 20, mana: 50, crit: 10 }, skill: { name: '', desc: '' } },
                'Beastie': { displayName: '', cost: 1, tier: 1, traits: ['Beast', 'Tank'], icon: 'ra ra-pawprint', type: 'tank', stats: { hp: 750, ad: 45, range: 1, armor: 45, mana: 70, crit: 10 }, skill: { name: '', desc: '' } },
                'Aqua': { displayName: '', cost: 1, tier: 1, traits: ['Frost', 'Enchanter'], icon: 'ra ra-water-drop', type: 'enchanter', stats: { hp: 500, ad: 35, range: 3, armor: 25, mana: 90, crit: 10 }, skill: { name: '', desc: 'HP' } },
                'Darko': { displayName: '', cost: 1, tier: 1, traits: ['Dark', 'Warrior'], icon: 'ra ra-scythe', type: 'fighter', stats: { hp: 600, ad: 60, range: 1, armor: 30, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                // -- TIER 2 --
                'Ignis': { displayName: '', cost: 2, tier: 2, traits: ['Pyro', 'Mage'], icon: 'ra ra-torch', type: 'mage', stats: { hp: 550, ad: 50, range: 3, armor: 25, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Glacia': { displayName: '', cost: 2, tier: 2, traits: ['Frost', 'Sniper'], icon: 'ra ra-snowflake', type: 'ranger', stats: { hp: 550, ad: 60, range: 4, armor: 25, mana: 70, crit: 10 }, skill: { name: '', desc: '' } },
                'Metalo': { displayName: '', cost: 2, tier: 2, traits: ['Machine', 'Tank'], icon: 'ra ra-anvil', type: 'tank', stats: { hp: 850, ad: 55, range: 1, armor: 50, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Blade': { displayName: '', cost: 2, tier: 2, traits: ['Dark', 'Assassin'], icon: 'ra ra-plain-dagger', type: 'assassin', stats: { hp: 600, ad: 75, range: 1, armor: 25, mana: 50, crit: 10 }, skill: { name: '', desc: '' } },
                'Gaia': { displayName: '', cost: 2, tier: 2, traits: ['Beast', 'Warrior'], icon: 'ra ra-heavy-shield', type: 'fighter', stats: { hp: 800, ad: 65, range: 1, armor: 40, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Nova': { displayName: '', cost: 2, tier: 2, traits: ['Light', 'Scholar', 'Cosmic'], icon: 'ra ra-sun-symbol', type: 'mage', stats: { hp: 500, ad: 45, range: 3, armor: 25, mana: 110, crit: 10 }, skill: { name: '', desc: '' } },
                'Vector': { displayName: '', cost: 2, tier: 2, traits: ['Cyber', 'Warrior'], icon: 'ra ra-sword', type: 'fighter', stats: { hp: 700, ad: 70, range: 1, armor: 35, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Bolt': { displayName: '', cost: 2, tier: 2, traits: ['Machine', 'Sniper'], icon: 'ra ra-lightning-storm', type: 'ranger', stats: { hp: 550, ad: 65, range: 5, armor: 20, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Luna': { displayName: '', cost: 2, tier: 2, traits: ['Dark', 'Enchanter'], icon: 'ra ra-moon-sun', type: 'enchanter', stats: { hp: 600, ad: 40, range: 3, armor: 30, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Giga': { displayName: '', cost: 2, tier: 2, traits: ['Void', 'Tank'], icon: 'ra ra-armor-vest', type: 'tank', stats: { hp: 900, ad: 45, range: 1, armor: 45, mana: 90, crit: 10 }, skill: { name: '', desc: '' } },
                // -- TIER 3 --
                'Vortex': { displayName: '', cost: 3, tier: 3, traits: ['Void', 'Mage'], icon: 'ra ra-spiral', type: 'mage', stats: { hp: 650, ad: 50, range: 3, armor: 30, mana: 120, crit: 10 }, skill: { name: '', desc: '' } },
                'Frosty': { displayName: '', cost: 3, tier: 3, traits: ['Frost', 'Tank'], icon: 'ra ra-ice-cube', type: 'tank', stats: { hp: 950, ad: 60, range: 1, armor: 50, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Ember': { displayName: '', cost: 3, tier: 3, traits: ['Pyro', 'Assassin'], icon: 'ra ra-flaming-claw', type: 'assassin', stats: { hp: 700, ad: 85, range: 1, armor: 35, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Cyber_X': { displayName: 'X', cost: 3, tier: 3, traits: ['Cyber', 'Sniper'], icon: 'ra ra-laser-blast', type: 'ranger', stats: { hp: 650, ad: 80, range: 4, armor: 25, mana: 70, crit: 10 }, skill: { name: '', desc: '' } },
                'Mysti': { displayName: '', cost: 3, tier: 3, traits: ['Dark', 'Enchanter'], icon: 'ra ra-bleeding-eye', type: 'enchanter', stats: { hp: 650, ad: 45, range: 3, armor: 40, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Rex': { displayName: '', cost: 3, tier: 3, traits: ['Beast', 'Warrior'], icon: 'ra ra-dinosaur', type: 'fighter', stats: { hp: 1000, ad: 90, range: 1, armor: 45, mana: 90, crit: 10 }, skill: { name: '', desc: 'HP' } },
                'Zero': { displayName: '', cost: 3, tier: 3, traits: ['Epoch', 'Assassin'], icon: 'ra ra-hourglass', type: 'assassin', stats: { hp: 600, ad: 90, range: 1, armor: 30, mana: 40, crit: 10 }, skill: { name: '', desc: '' } },
                'Draco': { displayName: '', cost: 3, tier: 3, traits: ['Dragon', 'Warrior'], icon: 'ra ra-dragon-wing', type: 'fighter', stats: { hp: 1100, ad: 75, range: 1, armor: 45, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Nexus': { displayName: '', cost: 3, tier: 3, traits: ['Machine', 'Warrior'], icon: 'ra ra-gear-hammer', type: 'fighter', stats: { hp: 850, ad: 85, range: 1, armor: 45, mana: 70, crit: 10 }, skill: { name: '', desc: '' } },
                'Aura': { displayName: '', cost: 3, tier: 3, traits: ['Light', 'Mage', 'Cosmic'], icon: 'ra ra-sun-symbol', type: 'mage', stats: { hp: 600, ad: 40, range: 4, armor: 30, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Zephyr': { displayName: '', cost: 3, tier: 3, traits: ['Light', 'Sniper', 'Cosmic'], icon: 'ra ra-lightning-bolt', type: 'ranger', stats: { hp: 600, ad: 75, range: 5, armor: 20, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Toro': { displayName: '', cost: 3, tier: 3, traits: ['Beast', 'Tank'], icon: 'ra ra-horned-helm', type: 'tank', stats: { hp: 1100, ad: 50, range: 1, armor: 55, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Shadow': { displayName: '', cost: 3, tier: 3, traits: ['Dark', 'Scholar'], icon: 'ra ra-hood', type: 'mage', stats: { hp: 600, ad: 50, range: 3, armor: 30, mana: 120, crit: 10 }, skill: { name: '', desc: '' } },
                'Gears': { displayName: '', cost: 3, tier: 3, traits: ['Machine', 'Scholar'], icon: 'ra ra-wrench', type: 'enchanter', stats: { hp: 700, ad: 45, range: 3, armor: 40, mana: 90, crit: 10 }, skill: { name: '', desc: '' } },
                'Void_S': { displayName: 'S', cost: 3, tier: 3, traits: ['Void', 'Assassin'], icon: 'ra ra-knife', type: 'assassin', stats: { hp: 650, ad: 100, range: 1, armor: 25, mana: 40, crit: 10 }, skill: { name: '', desc: '' } },
                // -- TIER 4 --
                'Atlas': { displayName: '', cost: 4, tier: 4, traits: ['Cyber', 'Tank'], icon: 'ra ra-tower', type: 'tank', stats: { hp: 1400, ad: 80, range: 1, armor: 70, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Inferno': { displayName: '', cost: 4, tier: 4, traits: ['Pyro', 'Mage'], icon: 'ra ra-fire', type: 'mage', stats: { hp: 900, ad: 70, range: 3, armor: 40, mana: 130, crit: 10 }, skill: { name: '', desc: '' } },
                'Blizzard': { displayName: '', cost: 4, tier: 4, traits: ['Frost', 'Scholar'], icon: 'ra ra-ice-cube', type: 'mage', stats: { hp: 850, ad: 60, range: 4, armor: 45, mana: 90, crit: 10 }, skill: { name: '', desc: '' } },
                'Phantom': { displayName: '', cost: 4, tier: 4, traits: ['Dark', 'Assassin'], icon: 'ra ra-skull', type: 'assassin', stats: { hp: 1000, ad: 130, range: 1, armor: 40, mana: 50, crit: 10 }, skill: { name: '', desc: 'HP' } },
                'Mecha_H': { displayName: 'H', cost: 4, tier: 4, traits: ['Machine', 'Sniper'], icon: 'ra ra-musket', type: 'ranger', stats: { hp: 900, ad: 110, range: 6, armor: 50, mana: 70, crit: 10 }, skill: { name: '', desc: '' } },
                'Seraph': { displayName: '', cost: 4, tier: 4, traits: ['Light', 'Enchanter', 'Cosmic'], icon: 'ra ra-angel-wings', type: 'enchanter', stats: { hp: 850, ad: 65, range: 5, armor: 40, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Omega': { displayName: '', cost: 4, tier: 4, traits: ['Cyber', 'Warrior'], icon: 'ra ra-broadsword', type: 'fighter', stats: { hp: 1200, ad: 140, range: 1, armor: 55, mana: 60, crit: 10 }, skill: { name: '', desc: '' } },
                'Behemoth': { displayName: '', cost: 4, tier: 4, traits: ['Beast', 'Tank'], icon: 'ra ra-monster-skull', type: 'tank', stats: { hp: 1600, ad: 90, range: 1, armor: 65, mana: 80, crit: 10 }, skill: { name: '', desc: '' } },
                'Xenon': { displayName: '', cost: 4, tier: 4, traits: ['Void', 'Warrior'], icon: 'ra ra-crossed-swords', type: 'fighter', stats: { hp: 1100, ad: 125, range: 1, armor: 50, mana: 50, crit: 10 }, skill: { name: '', desc: '' } },
                'Astra': { displayName: '', cost: 4, tier: 4, traits: ['Dragon', 'Scholar'], icon: 'ra ra-burning-meteor', type: 'mage', stats: { hp: 1000, ad: 115, range: 4, armor: 45, mana: 90, crit: 10 }, skill: { name: '', desc: '' } },
                // -- TIER 5 --
                'Eternity': { displayName: '', cost: 5, tier: 5, traits: ['Epoch', 'Scholar'], icon: 'ra ra-stopwatch', type: 'mage', stats: { hp: 2000, ad: 150, range: 4, armor: 100, mana: 150, crit: 10 }, skill: { name: '', desc: '' } },
                'Abyss': { displayName: '', cost: 5, tier: 5, traits: ['Void', 'Dark'], icon: 'ra ra-spiral', type: 'fighter', stats: { hp: 1800, ad: 140, range: 1, armor: 80, mana: 120, crit: 10 }, skill: { name: '', desc: '' } },
                'Sol': { displayName: '', cost: 5, tier: 5, traits: ['Light', 'Dragon', 'Cosmic'], icon: 'ra ra-sun', type: 'mage', stats: { hp: 2200, ad: 130, range: 5, armor: 90, mana: 200, crit: 10 }, skill: { name: '', desc: '' } },
                'Mecha_Z': { displayName: 'Z', cost: 5, tier: 5, traits: ['Machine', 'Warrior'], icon: 'ra ra-gear-hammer', type: 'tank', stats: { hp: 2500, ad: 200, range: 1, armor: 120, mana: 100, crit: 10 }, skill: { name: '', desc: '' } },
                'Chronos': { displayName: '', cost: 5, tier: 5, traits: ['Epoch', 'Assassin'], icon: 'ra ra-stopwatch', type: 'assassin', stats: { hp: 1500, ad: 180, range: 1, armor: 70, mana: 50, crit: 10 }, skill: { name: '', desc: '' } }
            };

            // ===== UNIT CLASS =====
            class Unit {
                constructor(id, name, data, owner) {
                    this.id = id;
                    this.name = name;
                    this.cost = data.cost;
                    this.tier = data.tier;
                    this.traits = [...data.traits];
                    this.type = data.type;
                    this.stats = { ...data.stats };
                    if (this.stats.ap === undefined) this.stats.ap = 100; // Fix AP 0 issue
                    this.maxHp = data.stats.hp;
                    this.currentHp = data.stats.hp;
                    this.mana = data.stats.initialMana || 0;
                    this.maxMana = data.stats.mana || 100;
                    this.owner = owner;
                    this.starLevel = 1;
                    this.row = -1;
                    this.col = -1;
                    this.isBench = true;
                    this.isUpgrading = false;
                    this.prevRow = -1;
                    this.prevCol = -1;
                    this.items = []; // Max 3 items
                    this.skill = data.skill || { name: '', desc: '' };
                    this.recommendedItems = data.recommendedItems || [];
                }

                // Shield Accessor for visual decay effect
                get shield() { return this._shield || 0; }
                set shield(v) {
                    const prev = this._shield || 0;
                    this._shield = v;
                    if (v > prev) {
                        this.maxShield = v; // Reset max on increase for full bar visual
                    }
                    if (v <= 0) this.maxShield = 0;
                }

                upgrade() {
                    this.starLevel++;
                    this.maxHp = Math.floor(this.maxHp * 1.8);
                    this.currentHp = this.maxHp;
                    this.stats.ad = Math.floor(this.stats.ad * 1.5);
                    this.stats.ap = Math.floor((this.stats.ap || 0) * 1.5);
                    this.stats.armor = Math.floor((this.stats.armor || 20) * 1.2);
                    this.stats.mr = Math.floor((this.stats.mr || 20) * 1.2);
                    this.stats.hp = this.maxHp;
                }

                savePos() { this.prevRow = this.row; this.prevCol = this.col; }
                resetPos() {
                    if (this.prevRow !== undefined && this.prevRow >= 0 && this.prevRow < 4 &&
                        this.prevCol !== undefined && this.prevCol >= 0 && this.prevCol < 7 && !this.isBench) {
                        this.row = this.prevRow;
                        this.col = this.prevCol;
                    }
                }

                addMana(amt) {
                    if (this.isUpgrading) return;
                    this.mana = Math.min(this.maxMana, this.mana + amt);
                }

                getStat(key) {
                    return this.getStatDetails(key).total;
                }

                getStatDetails(key) {
                    let base = this.stats[key] || 0;
                    let item = 0;
                    let augment = 0;
                    let synergy = 0;

                    // Items
                    this.items.forEach(it => {
                        let s = null;
                        // Resolve item stats from ID or object
                        if (typeof it === 'number') s = (typeof BASE_ITEMS !== 'undefined' && BASE_ITEMS[it]) ? BASE_ITEMS[it].stats : null;
                        else if (typeof it === 'string') s = (typeof ITEM_RECIPES !== 'undefined' && ITEM_RECIPES[it]) ? ITEM_RECIPES[it].stats : null;
                        else if (typeof it === 'object' && it.stats) s = it.stats;

                        if (s && s[key]) item += s[key];
                    });

                    // Thief's Gloves Temporary Items
                    if (this.thiefItems) {
                        this.thiefItems.forEach(itId => {
                            const s = ITEM_RECIPES[itId] ? ITEM_RECIPES[itId].stats : null;
                            if (s && s[key]) item += s[key];
                        });
                    }

                    // Augments
                    if (this.augmentBonuses) {
                        if (this.augmentBonuses[key] !== undefined) augment += this.augmentBonuses[key];
                        let current = base + item + augment;
                        if (key === 'ad' && this.augmentBonuses.adPct) augment += current * (this.augmentBonuses.adPct / 100);
                        if (key === 'attackSpeed' && this.augmentBonuses.asPct) augment += current * (this.augmentBonuses.asPct / 100);
                    }

                    // Synergies
                    if (this.synergyBonuses && this.synergyBonuses[key]) synergy += this.synergyBonuses[key];

                    // Dynamic combat bonuses
                    let combat = 0;
                    if (key === 'ap' && this.archangelStacks) combat += this.archangelStacks;
                    if (key === 'armor' && this.gargoyleBonus) combat += this.gargoyleBonus;
                    if (key === 'mr' && this.gargoyleBonus) combat += this.gargoyleBonus;
                    if (key === 'attackSpeed' && this.tempAttackSpeed) combat += this.tempAttackSpeed;
                    if (key === 'armor' && this.titanStacks) combat += this.titanStacks * 2;
                    if (key === 'mr' && this.titanStacks) combat += this.titanStacks * 2;
                    if (key === 'armor' && this.armorShred) combat -= base * this.armorShred; // For targets

                    return {
                        base: Math.floor(base),
                        item: Math.floor(item),
                        augment: Math.floor(augment),
                        synergy: Math.floor(synergy),
                        total: Math.floor(base + item + augment + synergy + combat)
                    };
                }

                takeDamage(amount, type) {
                    if (this.isInvulnerable) return;
                    let remaining = Math.ceil(amount);
                    if (remaining <= 0) return;

                    // Shield Absorb
                    if (this.shield > 0) {
                        const absorb = Math.min(this.shield, remaining);
                        this.shield -= absorb;
                        remaining -= absorb;
                        if (absorb > 0 && typeof showDamage === 'function') showDamage(this, absorb, 'shield');
                    }

                    // HP Damage
                    if (remaining > 0) {
                        this.currentHp -= remaining;
                        if (typeof showDamage === 'function') showDamage(this, remaining, type);
                    }
                }

                heal(amount) {
                    if (amount <= 0 || this.currentHp <= 0) return 0;
                    const actualHeal = Math.min(this.maxHp - this.currentHp, amount);
                    this.currentHp += actualHeal;
                    if (actualHeal > 0 && typeof showDamage === 'function') {
                        showDamage(this, actualHeal, 'heal');
                    }
                    return actualHeal;
                }

                castSkill(targets, game) {
                    if (this.mana < this.maxMana) return false;
                    this.mana = 0;
                    this.skillUsed = true; // Flag for mana highlight

                    const skillName = this.skill.name;
                    const power = (this.getStat('ap') || 100) + (this.starLevel * 30);
                    const adPower = this.getStat('ad') * (1 + this.starLevel * 0.5);
                    const isMagic = this.type === 'mage' || this.type === 'enchanter';
                    const allies = game ? (this.owner === 'player' ?
                        game.playerUnits.filter(u => !u.isBench && u.currentHp > 0) :
                        game.botUnits.filter(u => !u.isBench && u.currentHp > 0)) : [];

                    // === SPECIFIC SKILL IMPLEMENTATIONS ===

                    // --- Stun/Freeze Skills ---
                    if (skillName.includes('') || skillName.includes('') || skillName.includes('')) {
                        const stunTargets = targets.slice(0, skillName.includes('') ? 5 : 3);
                        const durTicks = 3 + this.starLevel; // ~2-3 seconds in ticks
                        stunTargets.forEach(t => {
                            t.isStunned = true;
                            t.stunEndTick = (game ? game.combatTime : 0) + durTicks;
                            showDamage(t, 0, 'true');
                        });
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('') || skillName.includes('')) {
                        const freezeTargets = skillName.includes('') ? targets : targets.slice(0, 3);
                        const durTicks = 3 + this.starLevel;
                        freezeTargets.forEach(t => {
                            t.isFrozen = true;
                            t.isStunned = true;
                            t.stunEndTick = (game ? game.combatTime : 0) + durTicks;
                        });
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('')) {
                        const durTicks = 5 + this.starLevel;
                        targets.forEach(t => {
                            t.isStunned = true;
                            t.stunEndTick = (game ? game.combatTime : 0) + durTicks;
                        });
                        return true;
                    }

                    // --- Heal Skills ---
                    if (skillName.includes('') || skillName.includes('') || skillName.includes('')) {
                        const healTarget = allies.sort((a, b) => (a.currentHp / a.maxHp) - (b.currentHp / b.maxHp))[0];
                        if (healTarget) {
                            const healAmt = 100 + power * 0.5;
                            healTarget.heal(healAmt);
                        }
                        if (skillName.includes('')) {
                            allies.forEach(a => a.heal(30 + power * 0.1));
                        }
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('')) {
                        if (targets.length > 0) {
                            const t = targets[0];
                            const dam = Math.ceil(adPower * 0.8);
                            const red = 100 / (100 + t.getStat('armor'));
                            const finalDam = Math.ceil(dam * red);
                            t.takeDamage(finalDam, 'ad');
                            this.heal(Math.ceil(finalDam * 0.5));
                        }
                        return true;
                    }

                    if (skillName.includes('')) {
                        const durTicks = 3;
                        allies.forEach(a => {
                            a.isInvulnerable = true;
                            a.invulnEndTick = (game ? game.combatTime : 0) + durTicks;
                        });
                        return true;
                    }

                    // --- Defense/Buff Skills ---
                    if (skillName.includes('') || skillName.includes('')) {
                        allies.forEach(a => {
                            a.tempArmor = (a.tempArmor || 0) + 30 + this.starLevel * 10;
                        });
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('')) {
                        this.tempAttackSpeed = (this.tempAttackSpeed || 0) + 0.5;
                        return true;
                    }

                    if (skillName.includes('')) {
                        this.reflectDamage = 0.3 + this.starLevel * 0.1;
                        return true;
                    }

                    // --- AOE Damage Skills ---
                    if (skillName.includes('') || skillName.includes('') || skillName.includes('') || skillName.includes('')) {
                        const aoeTargets = skillName.includes('') || skillName.includes('') ? targets : targets.slice(0, 4);
                        aoeTargets.forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.magicPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('mr') * (1 - pen)));
                            const finalDam = Math.ceil((80 + power * 0.8) * red);
                            t.isBurning = true;
                            t.takeDamage(finalDam, 'ap');
                        });
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('')) {
                        targets.slice(0, 3).forEach(t => {
                            const red = 100 / (100 + t.getStat('mr'));
                            const finalDam = Math.ceil((100 + power) * red);
                            t.takeDamage(finalDam, 'ap');
                        });
                        return true;
                    }

                    if (skillName.includes('') || skillName.includes('')) {
                        targets.slice(0, 3).forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * red);
                            t.takeDamage(finalDam, 'ad');
                        });
                        return true;
                    }

                    // --- Single Target Burst ---
                    if (skillName.includes('')) {
                        // Execute low HP target
                        const lowHpTarget = targets.sort((a, b) => a.currentHp - b.currentHp)[0];
                        if (lowHpTarget && lowHpTarget.currentHp < lowHpTarget.maxHp * 0.3) {
                            lowHpTarget.currentHp = 0;
                            showDamage(lowHpTarget, 9999, 'true');
                        } else if (targets[0]) {
                            const dam = adPower * 2;
                            const red = 100 / (100 + targets[0].getStat('armor'));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'crit');
                        }
                        return true;
                    }

                    if (skillName.includes('')) {
                        // True damage ignores armor
                        if (targets[0]) {
                            const finalDam = Math.ceil(adPower);
                            targets[0].takeDamage(finalDam, 'true');
                        }
                        return true;
                    }

                    if (skillName.includes('')) {
                        // Pierce through multiple targets
                        targets.slice(0, 3).forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * 0.8 * red);
                            t.takeDamage(finalDam, 'ad');
                        });
                        return true;
                    }

                    // --- Mana Skills ---
                    // --- Mana Skills ---
                    if (skillName.includes('') || skillName.includes('')) {
                        allies.forEach(a => {
                            a.mana = Math.min(a.maxMana, a.mana + 20 + this.starLevel * 10);
                        });
                        // Supernova also deals damage
                        if (skillName.includes('')) {
                            targets.slice(0, 3).forEach(t => {
                                const pen = this.synergyBonuses && this.synergyBonuses.magicPen || 0;
                                const red = 100 / (100 + Math.max(0, t.getStat('mr') * (1 - pen)));
                                const finalDam = Math.ceil((100 + power * 0.5) * red);
                                t.currentHp -= finalDam;
                                showDamage(t, finalDam, 'ap');
                            });
                        }
                        return true;
                    }

                    // --- Movement/Assassin Skills ---
                    // --- Movement/Assassin Skills ---
                    if (skillName.includes('') || skillName.includes('') || skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 1.5;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].currentHp -= finalDam;
                            showDamage(targets[0], finalDam, 'crit');
                        }
                        return true;
                    }

                    // --- Additional Skills ---
                    //  (Volca)
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 2;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'crit');
                            targets[0].isBurning = true;
                        }
                        return true;
                    }

                    //  (Shiro)
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 1.5;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'ad');
                            targets[0].isFrozen = true;
                            targets[0].isStunned = true;
                            targets[0].stunEndTick = (game ? game.combatTime : 0) + 3;
                        }
                        return true;
                    }

                    //  (Voida)
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 2.5;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'crit');
                        }
                        return true;
                    }

                    //  (Beastie) - 
                    if (skillName.includes('')) {
                        this.tempArmor = (this.tempArmor || 0) + 50 + this.starLevel * 20;
                        allies.forEach(a => {
                            a.tempArmor = (a.tempArmor || 0) + 20;
                        });
                        return true;
                    }

                    //  (Glacia)
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 1.3;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'ad');
                            targets[0].isFrozen = true;
                            targets[0].isStunned = true;
                            targets[0].stunEndTick = (game ? game.combatTime : 0) + 4;
                        }
                        return true;
                    }

                    //  (Vector)
                    if (skillName.includes('')) {
                        targets.slice(0, 2).forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * 0.7 * red);
                            t.takeDamage(finalDam, 'ad');
                        });
                        return true;
                    }

                    //  (Bolt) - 
                    if (skillName.includes('')) {
                        targets.slice(0, 4).forEach((t, i) => {
                            const chainMultiplier = 1 - (i * 0.15);
                            const red = 100 / (100 + t.getStat('mr'));
                            const finalDam = Math.ceil(adPower * chainMultiplier * red);
                            t.takeDamage(finalDam, 'ap');
                        });
                        return true;
                    }

                    //  (Cyber_X) - 
                    if (skillName.includes('')) {
                        const lowArmorTarget = targets.sort((a, b) => a.getStat('armor') - b.getStat('armor'))[0];
                        if (lowArmorTarget) {
                            const finalDam = Math.ceil(adPower * 2);
                            lowArmorTarget.takeDamage(finalDam, 'crit');
                        }
                        return true;
                    }

                    //  (Aura)
                    if (skillName.includes('') || skillName.includes('')) {
                        targets.slice(0, 3).forEach(t => {
                            const red = 100 / (100 + t.getStat('mr'));
                            const finalDam = Math.ceil((60 + power * 0.7) * red);
                            t.takeDamage(finalDam, 'ap');
                        });
                        return true;
                    }

                    //  (Zephyr) - 
                    if (skillName.includes('')) {
                        targets.slice(0, 5).forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * 0.5 * red);
                            t.takeDamage(finalDam, 'ad');
                        });
                        return true;
                    }

                    //  (Toro) - +
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * 1.2 * red);
                            targets[0].takeDamage(finalDam, 'ad');
                            targets[0].isStunned = true;
                            targets[0].stunEndTick = (game ? game.combatTime : 0) + 2;
                        }
                        return true;
                    }

                    //  (Shadow)
                    if (skillName.includes('')) {
                        const durTicks = 4;
                        targets.slice(0, 3).forEach(t => {
                            t.isStunned = true;
                            t.stunEndTick = (game ? game.combatTime : 0) + durTicks;
                            const red = 100 / (100 + t.getStat('mr'));
                            const finalDam = Math.ceil((50 + power * 0.5) * red);
                            t.takeDamage(finalDam, 'ap');
                        });
                        return true;
                    }

                    //  (Void_S) - 
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 2.5;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'crit');
                        }
                        return true;
                    }

                    //  (Behemoth) - 
                    if (skillName.includes('')) {
                        targets.forEach(t => {
                            t.tempAdReduction = (t.tempAdReduction || 0) + 0.5;
                            t.isStunned = true;
                            t.stunEndTick = (game ? game.combatTime : 0) + 2;
                        });
                        return true;
                    }

                    //  (Mecha_Z) - 
                    if (skillName.includes('')) {
                        targets.forEach(t => {
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, t.getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(adPower * 0.6 * red);
                            t.takeDamage(finalDam, 'crit');
                            t.isBurning = true;
                        });
                        return true;
                    }

                    //  (Chronos) - 
                    if (skillName.includes('')) {
                        targets.slice(0, 3).forEach(t => {
                            const finalDam = Math.ceil(adPower * 1.2);
                            t.takeDamage(finalDam, 'true');
                        });
                        return true;
                    }

                    //  (Omega)
                    if (skillName.includes('')) {
                        if (targets[0]) {
                            const dam = adPower * 3;
                            const pen = this.synergyBonuses && this.synergyBonuses.armorPen || 0;
                            const red = 100 / (100 + Math.max(0, targets[0].getStat('armor') * (1 - pen)));
                            const finalDam = Math.ceil(dam * red);
                            targets[0].takeDamage(finalDam, 'crit');
                        }
                        return true;
                    }

                    // --- Generic fallback ---
                    if (isMagic && targets.length > 0) {
                        const t = targets[0];
                        const red = 100 / (100 + t.getStat('mr'));
                        const finalDam = Math.ceil((100 + power) * red);
                        t.takeDamage(finalDam, 'ap');
                        return true;
                    }

                    // Generic AD skill for physical units
                    if (targets.length > 0) {
                        const t = targets[0];
                        const red = 100 / (100 + t.getStat('armor'));
                        const finalDam = Math.ceil(adPower * 1.5 * red);
                        t.takeDamage(finalDam, 'ad');
                    }
                    return true;
                }
            }

            const ITEM_ICONS = { 1: '', 2: '', 3: '', 4: '', 5: '', 6: '', 7: '', 8: '', 9: '', 10: '' };
            const ROLE_JP = { tank: '', mage: '', fighter: '', assassin: '', ranger: '', enchanter: '', unknown: '' };
            // ===== GAME CLASS =====
            class Game {
                constructor() {
                    this.gold = 5; this.xp = 0; this.level = 1; this.hp = 100;
                    this.botGold = 5; this.botHp = 100; this.botLevel = 1; this.botXp = 0;
                    this.round = 1; this.stage = 1; this.phase = 'planning';
                    this.interest = 0;
                    this.streak = 0; // Positive for wine, negative for loss
                    this.botStreak = 0;

                    this.playerUnits = []; this.botUnits = [];
                    this.bench = Array(9).fill(null);
                    this.board = Array(4).fill(null).map(() => Array(7).fill(null));
                    this.botBench = Array(9).fill(null);
                    this.botBoard = Array(4).fill(null).map(() => Array(7).fill(null));
                    this.botBoard = Array(4).fill(null).map(() => Array(7).fill(null));
                    this.shopCards = [];
                    this.shopStars = []; // Stores star level for each shop card
                    this.selectedUnit = null;

                    // Inventory and Augments
                    this.augments = []; this.botAugments = []; // Chosen augments
                    this.augmentChoices = []; // Pending choices
                    this.isChoosingAugment = false;
                    this.draggedItem = null;
                    this.dragged = null;
                    this.freeRerolls = 0; // Trade Sector logic

                    // Initialize Inventory
                    this.inventory = Array(16).fill(null);
                    this.botInventory = Array(50).fill(null);
                    this.combatInterval = null;
                    this.combatTime = 0;

                    // Unit pool system (limited copies per unit)
                    this.unitPool = {};
                    const poolSizes = { 1: 29, 2: 22, 3: 18, 4: 12, 5: 10 };
                    Object.keys(UNIT_DATA).forEach(name => {
                        this.unitPool[name] = poolSizes[UNIT_DATA[name].tier] || 29;
                    });

                    this.botTargetSynergy = null;
                }

                start() {
                    this.fillShop();
                    this.botDeploy();
                    // Initial Items (3 random components)
                    this.giveItem(Math.floor(Math.random() * 10) + 1);
                    this.giveItem(Math.floor(Math.random() * 10) + 1);
                    this.giveItem(Math.floor(Math.random() * 10) + 1);
                    this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                    this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                    this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                    // Initial Augment selection moved to after stage 1-1 (endCombat)
                    updateUI();
                }

                spawnInitialAugment() {
                    this.isChoosingAugment = true;
                    const tier = 'silver'; // Initial augment is always silver
                    const candidates = AUGMENT_DATA.filter(a => a.tier === tier);
                    this.augmentChoices = candidates.sort(() => 0.5 - Math.random()).slice(0, 3);
                    this.augmentRerolls = [1, 1, 1];
                    this.augmentTier = tier;
                    this.botChooseAugment(tier);
                }

                spawnAugments() {
                    this.isChoosingAugment = true;
                    // Mixed tier selection - each augment can be different tier
                    const sNum = Math.floor((this.stage - 1) / 5) + 1;

                    const getRandomTier = () => {
                        const rand = Math.random();
                        if (sNum >= 4) return rand > 0.4 ? 'prismatic' : (rand > 0.2 ? 'gold' : 'silver');
                        if (sNum >= 3) return rand > 0.5 ? 'gold' : 'silver';
                        return rand > 0.7 ? 'gold' : 'silver';
                    };

                    // Pick 3 random augments with mixed tiers
                    const choices = [];
                    const usedIds = new Set();
                    for (let i = 0; i < 3; i++) {
                        const tier = getRandomTier();
                        const candidates = AUGMENT_DATA.filter(a => a.tier === tier && !usedIds.has(a.id));
                        if (candidates.length > 0) {
                            const pick = candidates[Math.floor(Math.random() * candidates.length)];
                            choices.push(pick);
                            usedIds.add(pick.id);
                        }
                    }
                    this.augmentChoices = choices;
                    this.augmentRerolls = [1, 1, 1];
                    this.augmentTier = 'mixed';
                    this.botChooseAugment('gold');

                    updateUI();
                }

                rerollAugment(idx) {
                    if (!this.augmentRerolls || this.augmentRerolls[idx] <= 0) return;

                    this.augmentRerolls[idx]--;
                    const currentTier = this.augmentChoices[idx].tier;
                    const candidates = AUGMENT_DATA.filter(a =>
                        a.tier === currentTier &&
                        !this.augmentChoices.some(c => c.id === a.id)
                    );
                    if (candidates.length > 0) {
                        const newAug = candidates[Math.floor(Math.random() * candidates.length)];
                        this.augmentChoices[idx] = newAug;
                        showToast(`${idx + 1}`);
                    }
                    updateUI();
                }

                chooseAugment(idx) {
                    const choice = this.augmentChoices[idx];
                    this.augments.push(choice);
                    this.isChoosingAugment = false;
                    this.applyAugmentImmediate(choice);
                    this.applyAugmentStats(); // Apply stats immediately
                    showToast(`${choice.name}`);
                    updateUI();
                    updateSynergyList();
                }

                applyAugmentImmediate(aug) {
                    if (aug.effect === 'free_reroll') { // Trade Sector Immediate Trigger
                        this.freeRerolls = (this.freeRerolls || 0) + aug.value;
                        showToast(': ');
                    }
                    if (aug.effect === 'immediate_rich') {
                        this.gold += 20;
                        this.giveItem(Math.floor(Math.random() * 10) + 1);
                        showToast(': 20G + ');
                    }
                    if (aug.effect === 'gain_gold') this.gold += aug.value;
                    if (aug.effect === 'gain_xp') {
                        this.xp += aug.value;
                        while (this.xp >= (XP_TABLE[this.level] || 999)) { this.xp -= XP_TABLE[this.level]; this.level++; }
                    }
                    if (aug.effect === 'gain_level') this.level++;
                    if (aug.effect === 'gain_component') this.giveItem(Math.floor(Math.random() * 10) + 1);
                    if (aug.effect === 'gain_completed_2') {
                        const recipes = Object.keys(ITEM_RECIPES).filter(k => !ITEM_RECIPES[k].traits);
                        for (let i = 0; i < 2; i++) {
                            const r = recipes[Math.floor(Math.random() * recipes.length)];
                            this.giveItem(r);
                        }
                    }
                    if (aug.effect === 'full_heal_player') this.hp = 100;
                    if (aug.effect === 'player_hp') { this.hp += aug.value; }
                    if (aug.effect === 'player_hp_huge') { this.hp += aug.value; }
                    if (aug.effect === 'eco_combo') {
                        this.gold += aug.value === 7 ? 15 : 30; // 7=15G, 10=30G
                    }
                    if (aug.effect === 'team_size') {
                        this.teamSizeBonus = (this.teamSizeBonus || 0) + aug.value;
                    }
                    if (aug.effect === 'cursed_size') {
                        this.teamSizeBonus = (this.teamSizeBonus || 0) + aug.value;
                        this.cursedCrown = true;
                    }
                    if (aug.effect === 'gain_item_thief') {
                        this.giveItem('8-8');
                    }
                    if (aug.effect === 'gain_item_thief_2') {
                        this.giveItem('8-8');
                        this.giveItem('8-8');
                    }
                    if (aug.effect === 'gain_item_mage') {
                        this.giveItem('3-9');
                    }
                    if (aug.effect === 'gain_item_warrior') {
                        this.giveItem('1-9');
                    }
                    // Synergy Heart Logic
                    if (aug.effect.startsWith('trait_')) {
                        const trait = aug.effect.replace('trait_', '');
                        // Capitalize first letter: mage -> Mage
                        const key = trait.charAt(0).toUpperCase() + trait.slice(1);
                        this.extraSynergies = this.extraSynergies || {};
                        this.extraSynergies[key] = (this.extraSynergies[key] || 0) + aug.value;
                    }
                }

                getAugmentValue(effect) {
                    return this.augments.filter(a => a.effect === effect).reduce((sum, a) => sum + a.value, 0);
                }

                getStreakBonus(s) {
                    const abs = Math.abs(s);
                    if (this.getAugmentValue('streak_double') > 0) {
                        if (abs >= 5) return 6;
                        if (abs >= 3) return 4;
                        if (abs >= 2) return 2;
                    }
                    if (abs >= 5) return 3;
                    if (abs >= 3) return 2;
                    if (abs >= 2) return 1;
                    return 0;
                }

                applyAugmentStats() {
                    this._applyAugments(this.playerUnits, this.augments, false);
                    this._applyAugments(this.botUnits, this.botAugments || [], true);
                }

                _applyAugments(units, augList, isBot) {
                    const getVal = (eff) => augList.filter(a => a.effect === eff).reduce((sum, a) => sum + a.value, 0);

                    const teamHp = getVal('team_hp');
                    const teamAd = getVal('team_ad');
                    const teamAp = getVal('team_ap');
                    const teamAs = getVal('team_as');
                    const teamArmor = getVal('team_armor');
                    const teamMr = getVal('team_mr');

                    const frontAd = getVal('front_ad');
                    const frontAp = getVal('front_ap');
                    const backRange = getVal('back_range');

                    const lowCostHp = getVal('low_cost_hp');
                    const lowCostAs = getVal('low_cost_as');
                    const marchHp = getVal('march');

                    units.forEach(u => {
                        u.augmentBonuses = { hp: 0, ad: 0, ap: 0, as: 0, armor: 0, mr: 0, range: 0 };

                        u.augmentBonuses.hp += teamHp + marchHp;
                        u.augmentBonuses.ad += teamAd;
                        u.augmentBonuses.ap += teamAp;
                        u.augmentBonuses.as += teamAs;
                        u.augmentBonuses.armor += teamArmor;
                        u.augmentBonuses.mr += teamMr;

                        // Row Logic: Front = Row 2,3 (Indices). Back = 0,1.
                        const rowLocal = u.isBench ? -1 : (isBot ? u.row : (u.row >= 4 ? u.row - 4 : u.row));

                        if (rowLocal >= 2) {
                            u.augmentBonuses.ad += frontAd;
                            u.augmentBonuses.ap += frontAp;
                        } else if (rowLocal >= 0) {
                            u.augmentBonuses.range += backRange;
                        }

                        if (u.cost <= 2) {
                            u.augmentBonuses.hp += lowCostHp;
                            u.augmentBonuses.as += lowCostAs;
                        }

                        // Recalculate MaxHP
                        let oldMax = u.maxHp;
                        let newMaxHp = u.stats.hp;
                        if (u.items) u.items.forEach(it => { if (it && it.stats && it.stats.hp) newMaxHp += it.stats.hp; });
                        newMaxHp += u.augmentBonuses.hp;

                        u.maxHp = Math.floor(newMaxHp);
                        if (u.maxHp > oldMax) u.currentHp += (u.maxHp - oldMax);
                        u.currentHp = Math.min(u.currentHp, u.maxHp);

                        // Apply start shield from augment
                        const startShieldVal = getVal('start_shield');
                        if (startShieldVal > 0) {
                            u.shield = (u.shield || 0) + startShieldVal;
                        }
                    });
                }

                botChooseAugment(tier) {
                    const candidates = AUGMENT_DATA.filter(a => a.tier === tier);
                    if (candidates.length === 0) return;
                    const pick = candidates[Math.floor(Math.random() * candidates.length)];
                    this.botAugments = this.botAugments || [];
                    this.botAugments.push(pick);

                    // Instant effects
                    if (pick.effect === 'gain_gold') this.botGold += pick.value;
                    if (pick.effect === 'gain_xp') {
                        this.botXp += pick.value;
                        while (this.botXp >= (XP_TABLE[this.botLevel] || 999)) { this.botXp -= XP_TABLE[this.botLevel]; this.botLevel++; }
                    }
                    if (pick.effect === 'gain_level') this.botLevel++;

                    // Item Augments
                    if (pick.effect === 'gain_component' || pick.effect === 'immediate_rich') {
                        this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                    }
                    if (pick.effect === 'gain_completed_2') {
                        // Give 2 components (simplification)
                        this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                        this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                    }
                    if (pick.effect === 'gain_item_thief' || pick.effect === 'gain_item_thief_2') this.botGiveItem('8-8');
                    if (pick.effect === 'gain_item_mage') this.botGiveItem('3-9'); // Mage Emblem
                    if (pick.effect === 'gain_item_warrior') this.botGiveItem('1-9'); // Warrior Emblem

                    // Synergy Heart Logic for Bot
                    if (pick.effect.startsWith('trait_')) {
                        const trait = pick.effect.replace('trait_', '');
                        const key = trait.charAt(0).toUpperCase() + trait.slice(1);
                        this.botExtraSynergies = this.botExtraSynergies || {};
                        this.botExtraSynergies[key] = (this.botExtraSynergies[key] || 0) + (pick.value || 1);
                    }
                }

                giveItem(itemId) {
                    const freeSlot = this.inventory.findIndex(s => s === null);
                    if (freeSlot !== -1) {
                        this.inventory[freeSlot] = itemId;
                        showToast(`: ${BASE_ITEMS[itemId].name}`);
                    }
                    updateUI();
                }

                botGiveItem(itemId) {
                    const freeSlot = this.botInventory.findIndex(s => s === null);
                    if (freeSlot !== -1) {
                        this.botInventory[freeSlot] = itemId;
                    }
                }

                botItemLogic() {
                    // 1. Unequip All
                    this.botUnits.forEach(u => {
                        if (u.items && u.items.length > 0) {
                            u.items.forEach(it => {
                                const free = this.botInventory.findIndex(s => s === null);
                                if (free !== -1) this.botInventory[free] = it;
                            });
                            u.items = [];
                            u.thiefItems = [];
                        }
                    });

                    // 2. Simple Auto-Combine
                    const inv = this.botInventory;
                    const tryCombine = () => {
                        let combined = false;
                        for (let i = 0; i < inv.length; i++) {
                            if (typeof inv[i] === 'number') {
                                for (let j = i + 1; j < inv.length; j++) {
                                    if (typeof inv[j] === 'number') {
                                        const k1 = `${inv[i]}-${inv[j]}`;
                                        const k2 = `${inv[j]}-${inv[i]}`;
                                        const resultId = ITEM_RECIPES[k1] ? k1 : (ITEM_RECIPES[k2] ? k2 : null);
                                        if (resultId) {
                                            inv[i] = resultId;
                                            inv[j] = null;
                                            combined = true;
                                            break;
                                        }
                                    }
                                }
                            }
                            if (combined) break;
                        }
                        if (combined) tryCombine();
                    };
                    tryCombine();

                    // 3. Equip Logic
                    const carryScore = (u) => {
                        let score = u.cost * 10 + (u.starLevel * 20);
                        if (u.type === 'ranger' || u.type === 'mage' || u.type === 'assassin' || u.type === 'fighter') score += 15;
                        return score;
                    };
                    // Sort units: Board units first, then Bench.
                    const sortedUnits = [...this.botUnits].sort((a, b) => {
                        if (a.isBench !== b.isBench) return (a.isBench ? 1 : 0) - (b.isBench ? 1 : 0);
                        return carryScore(b) - carryScore(a);
                    });

                    sortedUnits.forEach(u => {
                        if (u.isBench) return; // Prioritize board only for now
                        let slotsFree = 3 - (u.items ? u.items.length : 0);
                        if (slotsFree <= 0) return;

                        const recs = ROLE_RECOMMENDATIONS[u.type] || [];

                        // A. Recommended Items
                        for (let k = 0; k < inv.length; k++) {
                            if (inv[k] && slotsFree > 0) {
                                const it = inv[k];
                                if (recs.includes(it)) {
                                    u.items.push(it);
                                    inv[k] = null;
                                    slotsFree--;
                                }
                            }
                        }

                        // B. General Suitability
                        for (let k = 0; k < inv.length; k++) {
                            if (inv[k] && slotsFree > 0) {
                                const it = inv[k];
                                let data = (typeof it === 'string') ? ITEM_RECIPES[it] : BASE_ITEMS[it];
                                if (!data) continue;

                                let suitable = false;
                                if (u.type === 'tank' && (data.type === 'tank' || data.type === 'def')) suitable = true;
                                if ((u.type === 'mage' || u.type === 'enchanter') && (data.type === 'ap' || data.type === 'mana')) suitable = true;
                                if ((u.type === 'ranger' || u.type === 'assassin' || u.type === 'fighter') && (data.type === 'ad' || data.type === 'as' || data.type === 'crit')) suitable = true;
                                if (data.type === 'special') suitable = true;
                                if (typeof it === 'string' && !suitable) suitable = true; // Completed items are good regardless

                                // Component Check based on stats
                                if (!suitable && data.stats) {
                                    const s = data.stats;
                                    if (u.type === 'tank' && (s.hp || s.armor || s.mr)) suitable = true;
                                    if ((u.type === 'mage' || u.type === 'enchanter') && (s.ap || s.mana)) suitable = true;
                                    if ((u.type === 'ranger' || u.type === 'fighter' || u.type === 'assassin') && (s.ad || s.as || s.crit)) suitable = true;
                                }

                                if (suitable) {
                                    if (it === '8-8') { // Thief Gloves
                                        if (u.items.length === 0) {
                                            u.items.push(it);
                                            inv[k] = null;
                                            slotsFree = 0;
                                        }
                                    } else {
                                        u.items.push(it);
                                        inv[k] = null;
                                        slotsFree--;
                                    }
                                }
                            }
                        }
                    });
                }

                fillShop() {
                    this.shopCards = [];
                    this.shopStars = [];
                    const rates = DROP_RATES[this.level] || DROP_RATES[9];
                    const pool = Object.keys(UNIT_DATA);
                    for (let i = 0; i < 5; i++) {
                        let tier = 1, rand = Math.random() * 100, cum = 0;
                        for (let t = 0; t < 5; t++) { cum += rates[t]; if (rand <= cum) { tier = t + 1; break; } }

                        // Chance for 2-star unit (5%)
                        const isStar2 = Math.random() < 0.05;
                        this.shopStars.push(isStar2 ? 2 : 1);

                        // Find units in selected tier
                        let tierPool = pool.filter(k => UNIT_DATA[k].tier === tier && this.unitPool[k] > 0);

                        // FALLBACK: If selected tier is empty, check ALL tiers
                        if (tierPool.length === 0) {
                            const availableTiers = [1, 2, 3, 4, 5].sort(() => Math.random() - 0.5);
                            for (let t of availableTiers) {
                                tierPool = pool.filter(k => UNIT_DATA[k].tier === t && this.unitPool[k] > 0);
                                if (tierPool.length > 0) break;
                            }
                        }

                        if (tierPool.length > 0) {
                            const totalWeight = tierPool.reduce((sum, k) => sum + this.unitPool[k], 0);
                            let r = Math.random() * totalWeight;
                            let picked = false;
                            for (let k of tierPool) {
                                r -= this.unitPool[k];
                                if (r <= 0) {
                                    this.shopCards.push(k);
                                    picked = true;
                                    break;
                                }
                            }
                            if (!picked && tierPool.length > 0) this.shopCards.push(tierPool[tierPool.length - 1]);
                        } else {
                            this.shopCards.push(null);
                        }


                    }

                    // Final safety check: if we somehow have fewer than 5, pad with nulls
                    while (this.shopCards.length < 5) { this.shopCards.push(null); this.shopStars.push(1); }
                }

                initBotLoop() {
                    // simple bot loop
                    setInterval(() => {
                        if (this.phase === 'shopping') {
                            this.botLogic.shoppingTick(this.unitPool, SYNERGY_DATA, UNIT_DATA, XP_TABLE, DROP_RATES);
                            this.updateUI();
                        }
                    }, 1000);
                }

                // ===== ITEM LOGIC =====
                combineItems(idx1, idx2) {
                    if (idx1 === idx2) return;
                    const item1 = this.inventory[idx1];
                    const item2 = this.inventory[idx2];
                    if (!item1 || !item2) return;

                    // Only combine base items (numeric IDs)
                    if ((typeof item1 !== 'number') || (typeof item2 !== 'number')) {
                        showToast('');
                        return;
                    }

                    const key1 = `${item1}-${item2}`;
                    const key2 = `${item2}-${item1}`;
                    const recipe = ITEM_RECIPES[key1] || ITEM_RECIPES[key2];

                    if (recipe) {
                        // Remove ingredients
                        this.inventory[idx1] = null;
                        this.inventory[idx2] = null;

                        // Add result (key is the ID for completed item)
                        // Find first empty slot (reuse idx1 or idx2 preferably, or find new)
                        // Actually, we should put it in the drop target slot (idx2 usually?)
                        // Let's put in idx2 (target)
                        const resultId = ITEM_RECIPES[key1] ? key1 : key2;
                        this.inventory[idx2] = resultId;

                        showToast(`${recipe.name}`);
                        updateUI();
                        playSound('buy');
                    } else {
                        showToast('');
                    }
                }

                equipItem(unit, itemIdx) {
                    const item = this.inventory[itemIdx];
                    if (!item) return;
                    if (!unit.items) unit.items = [];

                    if (unit.items.length >= 3) {
                        showToast('');
                        return;
                    }

                    // Check for Thief's Gloves (8-8)
                    if (item === '8-8') {
                        // Thief's Gloves takes all 3 slots and grants 2 random completed items
                        if (unit.items.length > 0) {
                            showToast('');
                            return;
                        }

                        this.inventory[itemIdx] = null;
                        unit.items.push(item);

                        // Generate 2 random completed items (not emblems or special items)
                        const validRecipes = Object.keys(ITEM_RECIPES).filter(key => {
                            const recipe = ITEM_RECIPES[key];
                            return recipe && !recipe.traits && recipe.effect !== 'thief' && recipe.effect !== 'fon';
                        });

                        unit.thiefItems = [];
                        for (let i = 0; i < 2; i++) {
                            const randomIdx = Math.floor(Math.random() * validRecipes.length);
                            unit.thiefItems.push(validRecipes[randomIdx]);
                        }

                        showToast(`${ITEM_RECIPES[unit.thiefItems[0]]?.name}${ITEM_RECIPES[unit.thiefItems[1]]?.name}`);
                        updateUI();
                        playSound('ui');
                        return;
                    }

                    // Check for emblem items - can't equip to units that already have that trait
                    if (typeof item === 'string' && ITEM_RECIPES[item]?.traits) {
                        const emblemTraits = ITEM_RECIPES[item].traits;
                        const unitTraits = unit.traits || [];
                        const hasTrait = emblemTraits.some(t => unitTraits.includes(t));
                        if (hasTrait) {
                            showToast(``);
                            return;
                        }
                    }

                    this.inventory[itemIdx] = null;
                    unit.items.push(item);
                    showToast('');
                    updateUI();
                    playSound('ui');
                }

                unequipItem(unit, itemSlotIdx) {
                    if (this.phase === 'combat') {
                        showToast('');
                        return;
                    }
                    const item = unit.items[itemSlotIdx];
                    if (!item) return;

                    const freeSlot = this.inventory.findIndex(s => s === null);
                    if (freeSlot === -1) {
                        showToast('');
                        return;
                    }

                    unit.items.splice(itemSlotIdx, 1);
                    this.inventory[freeSlot] = item;
                    updateUI();
                    playSound('ui');
                }

                updateItemGuide() {
                    const container = document.getElementById('guide-content-recommended');
                    if (!container) return;

                    // Show role based recommendations based on selected unit or first unit in board
                    let targetUnit = this.selectedUnit || (this.playerUnits.length > 0 ? this.playerUnits.filter(u => !u.isBench)[0] : null);

                    if (!targetUnit) {
                        container.innerHTML = '<div style="padding:10px;text-align:center;color:#555;"></div>';
                        return;
                    }

                    const unitDef = UNIT_DATA[targetUnit.name];
                    if (!unitDef) return;

                    container.innerHTML = '';

                    const role = unitDef.type;
                    const roleName = ROLE_JP[role] || role;
                    const header = document.createElement('div');
                    header.className = 'guide-section-title';
                    header.textContent = `${unitDef.displayName} (${roleName})`;
                    container.appendChild(header);

                    const recs = ROLE_RECOMMENDATIONS[role] || [];

                    if (recs.length === 0) {
                        container.innerHTML += '<div style="color:#777;"></div>';
                        return;
                    }

                    recs.forEach(key => {
                        const recipe = ITEM_RECIPES[key];
                        if (!recipe) return;

                        const parts = key.split('-').map(Number);

                        const row = document.createElement('div');
                        row.className = 'rec-row';

                        // Recipe Icons
                        const iconBox = document.createElement('div');
                        iconBox.style.display = 'flex';
                        iconBox.style.marginRight = '8px';

                        parts.forEach(p => {
                            const box = document.createElement('div');
                            box.className = `item-icon-box mat-${p}`;
                            box.style.width = '24px'; box.style.height = '24px'; box.style.fontSize = '14px'; box.style.marginRight = '2px';

                            const iconClass = BASE_ITEMS[p] ? BASE_ITEMS[p].icon : '';
                            if (iconClass) {
                                box.innerHTML = `<i class="${iconClass}"></i>`;
                            } else {
                                box.textContent = '?';
                            }
                            iconBox.appendChild(box);
                        });

                        const info = document.createElement('div');
                        info.innerHTML = `<div class="rec-name">${recipe.name}</div><div class="rec-desc">${recipe.desc}</div>`;

                        row.appendChild(iconBox);
                        row.appendChild(info);
                        container.appendChild(row);
                    });
                }



                buy(idx) {
                    if (this.phase === 'combat') return;
                    const name = this.shopCards[idx];
                    if (!name) return;

                    const star = this.shopStars[idx] || 1;
                    const baseCost = UNIT_DATA[name].cost;
                    // Calculate cost: Star 1 = Cost, Star 2 = Cost * 3
                    const cost = baseCost * Math.pow(3, star - 1);

                    if (this.gold < cost) { showToast(""); return; }

                    // Check for immediate upgrade potential
                    // If buying Star 2, we treat it as buying 3 Star 1s effectively for logic?
                    // No, just treat as a Unit with starLevel 2.
                    // Merging logic: if I have two Star 2s on board/bench, and I buy a Star 2, do they become Star 3?
                    // Yes. checkUpgrade logic needs to handle it.
                    // Currently checkUpgrade looks for 3 units of same starLevel. 
                    // So if we add a Star 2 unit, we just call checkUpgrade(name, 'player') and it should work if we have 2 others.

                    // Bench check
                    const emptyIdx = this.bench.findIndex(b => b === null);

                    // If this purchase would trigger an upgrade, we might not need a bench slot.
                    // But logic is complex (e.g. buying Star 2 when we have 2 Star 2s on bench).
                    // Let's require bench space for simplicity or merge if space exists.
                    if (emptyIdx !== -1) {
                        this.gold -= cost;
                        const u = new Unit(Date.now() + Math.random(), name, UNIT_DATA[name], 'player');

                        // Apply Star Level
                        if (star > 1) {
                            // u.starLevel starts at 1.
                            for (let k = 1; k < star; k++) u.upgrade();
                            u.isUpgrading = false; // Reset flag set by upgrade potentially? No, upgrade() doesn't set isUpgrading usually?
                            // check upgrade() method in Unit class.
                        }

                        this.playerUnits.push(u);
                        this.bench[emptyIdx] = u;

                        this.shopCards[idx] = null;
                        this.checkUpgrade(name, 'player');
                        updateUI();
                    } else {
                        // Try to auto-merge if we have matching units? 
                        // Too risky to implement without testing. Just show full.
                        // Exception: if we have 2 units of SAME STAR on bench/board, allow buy to merge?
                        // Let's implement smart merge check later if needed.
                        showToast("");
                    }
                }

                checkUpgrade(name, owner) {
                    const list = owner === 'player' ? this.playerUnits : this.botUnits;
                    for (let sl of [1, 2]) {
                        // Only count units NOT currently in the middle of an upgrade animation
                        const stars = list.filter(u => u.name === name && u.starLevel === sl && !u.isUpgrading);
                        if (stars.length >= 3) {
                            const toCombine = stars.slice(0, 3);
                            toCombine.forEach(u => u.isUpgrading = true);

                            // Decide which unit to keep (prioritize board units)
                            toCombine.sort((a, b) => (a.isBench ? 1 : 0) - (b.isBench ? 1 : 0));
                            const keep = toCombine[0];
                            const toRemove = [toCombine[1], toCombine[2]];

                            if (owner === 'player') {
                                updateUI();
                                toCombine.forEach(u => {
                                    const el = document.querySelector(`.unit[data-id="${u.id}"]`);
                                    if (el) el.classList.add('upgrading');
                                });

                                setTimeout(() => {
                                    toRemove.forEach(u => this.removeUnit(u, owner));
                                    keep.upgrade();
                                    keep.isUpgrading = false;

                                    // Ensure 'keep' has a valid slot if it's on the bench
                                    if (keep.isBench) {
                                        if (this.bench.indexOf(keep) === -1) {
                                            const freeIdx = this.bench.indexOf(null);
                                            if (freeIdx !== -1) this.bench[freeIdx] = keep;
                                        }
                                    }

                                    showToast(`${UNIT_DATA[keep.name].displayName}${keep.starLevel}`);
                                    this.checkUpgrade(name, owner); // Double upgrade check (level 2 -> 3)
                                    updateUI();
                                }, 500);
                            } else {
                                // Bot immediate upgrade
                                toRemove.forEach(u => this.removeUnit(u, owner));
                                keep.upgrade();
                                keep.isUpgrading = false;

                                // Bot internal bench sync
                                if (keep.isBench && this.botBench.indexOf(keep) === -1) {
                                    const bIdx = this.botBench.indexOf(null);
                                    if (bIdx !== -1) this.botBench[bIdx] = keep;
                                }

                                this.checkUpgrade(name, owner);
                            }
                            return;
                        }
                    }
                }

                checkAllUpgrades(owner) {
                    const list = owner === 'player' ? this.playerUnits : this.botUnits;
                    const names = [...new Set(list.map(u => u.name))];
                    names.forEach(name => this.checkUpgrade(name, owner));
                }

                removeUnit(u, owner) {
                    if (owner === 'player') {
                        this.playerUnits = this.playerUnits.filter(x => x !== u);
                        if (u.isBench) { const i = this.bench.indexOf(u); if (i !== -1) this.bench[i] = null; }
                        else if (this.board[u.row]?.[u.col] === u) this.board[u.row][u.col] = null;
                    } else {
                        this.botUnits = this.botUnits.filter(x => x !== u);
                        if (u.isBench) { const i = this.botBench.indexOf(u); if (i !== -1) this.botBench[i] = null; }
                        else if (this.botBoard[u.row]?.[u.col] === u) this.botBoard[u.row][u.col] = null;
                    }
                }

                sell(unit) {
                    if (this.phase === 'combat' || unit.owner !== 'player') return;
                    const sellPrice = unit.cost * unit.starLevel;
                    this.gold += sellPrice;
                    this.unitPool[unit.name] += Math.pow(3, unit.starLevel - 1);
                    this.removeUnit(unit, 'player');
                    this.selectedUnit = null;
                    showToast(`${UNIT_DATA[unit.name].displayName} (+${sellPrice}G)`);
                    updateUI();
                }

                move(unit, target) {
                    if (this.phase === 'combat' || unit.owner !== 'player') return;
                    const oldBench = unit.isBench;
                    const oldRow = unit.row, oldCol = unit.col;
                    const oldBenchIdx = oldBench ? this.bench.indexOf(unit) : -1;

                    if (oldBench && oldBenchIdx !== -1) this.bench[oldBenchIdx] = null;
                    else if (!oldBench && this.board[oldRow]?.[oldCol] === unit) this.board[oldRow][oldCol] = null;

                    let targetUnit = null;
                    if (target.type === 'bench') {
                        targetUnit = this.bench[target.idx];
                        this.bench[target.idx] = unit;
                        unit.isBench = true; unit.row = -1; unit.col = -1;
                    } else {
                        targetUnit = this.board[target.r][target.c];
                        const boardCount = this.board.flat().filter(x => x).length;
                        if (!targetUnit && boardCount >= this.level && oldBench) {
                            showToast(` (Lv${this.level})`);
                            if (oldBench) this.bench[oldBenchIdx] = unit;
                            else this.board[oldRow][oldCol] = unit;
                            updateUI(); return;
                        }
                        this.board[target.r][target.c] = unit;
                        unit.isBench = false; unit.row = target.r; unit.col = target.c;
                    }

                    if (targetUnit) {
                        if (oldBench) { this.bench[oldBenchIdx] = targetUnit; targetUnit.isBench = true; targetUnit.row = -1; targetUnit.col = -1; }
                        else { this.board[oldRow][oldCol] = targetUnit; targetUnit.row = oldRow; targetUnit.col = oldCol; targetUnit.isBench = false; }
                    }

                    this.selectedUnit = null;
                    updateUI();
                }

                botDeploy() {
                    const myUnits = this.botUnits;
                    const boardLimit = this.botLevel;

                    // --- Synergy Strategy (Lv6+) ---
                    if (this.botLevel >= 6) {
                        // Check if current target is complete
                        if (this.botTargetSynergy) {
                            const counts = {};
                            myUnits.forEach(u => u.traits.forEach(t => counts[t] = (counts[t] || 0) + 1));
                            const currentVal = counts[this.botTargetSynergy] || 0;
                            const def = SYNERGY_DATA[this.botTargetSynergy];
                            const maxVal = def ? Math.max(...def.levels.map(l => l.count)) : 99;
                            if (currentVal >= maxVal) this.botTargetSynergy = null;
                        }

                        // Pick new target if needed
                        if (!this.botTargetSynergy) {
                            const sCounts = {};
                            const sStars = {};
                            myUnits.forEach(u => u.traits.forEach(t => {
                                sCounts[t] = (sCounts[t] || 0) + 1;
                                sStars[t] = (sStars[t] || 0) + u.starLevel;
                            }));
                            const valid = Object.keys(sCounts).filter(k => SYNERGY_DATA[k]);
                            valid.sort((a, b) => {
                                if (sCounts[b] !== sCounts[a]) return sCounts[b] - sCounts[a];
                                if (sStars[b] !== sStars[a]) return sStars[b] - sStars[a];
                                return Math.random() - 0.5;
                            });
                            if (valid.length > 0) this.botTargetSynergy = valid[0];
                        }
                    }

                    // --- Economy & Leveling ---
                    // Priority: Fill board > Save 20G > Level Up
                    const currentBoardCount = myUnits.filter(u => !u.isBench).length;
                    let safeGold = Math.max(0, this.botGold - 20);
                    if (currentBoardCount < boardLimit) safeGold = this.botGold;

                    // Level Up Check
                    const xpNeeded = (XP_TABLE[this.botLevel] || 999) - this.botXp;
                    const costToLevel = Math.ceil(xpNeeded / 4) * 4;
                    if (this.botLevel < 11 && safeGold >= costToLevel) {
                        while (this.botXp < (XP_TABLE[this.botLevel] || 999) && safeGold >= 4) {
                            this.botGold -= 4; this.botXp += 4; safeGold -= 4;
                            if (this.botXp >= XP_TABLE[this.botLevel]) { this.botXp -= XP_TABLE[this.botLevel]; this.botLevel++; }
                        }
                    }

                    // --- Shopping Logic ---
                    const lookLimit = (this.botGold > 30) ? 20 : 5;
                    let cardsLooked = 0;

                    const updateTraits = () => {
                        const map = {};
                        this.botUnits.forEach(u => u.traits.forEach(t => map[t] = (map[t] || 0) + 1));
                        return map;
                    };

                    while (cardsLooked < lookLimit && this.botGold >= 1) {
                        cardsLooked++;
                        const rates = DROP_RATES[this.botLevel] || DROP_RATES[9];
                        let tier = 1, rand = Math.random() * 100, cum = 0;
                        for (let t = 0; t < 5; t++) { cum += rates[t]; if (rand <= cum) { tier = t + 1; break; } }

                        // 5% Chance for Star 2
                        const isStar2 = Math.random() < 0.05;
                        const star = isStar2 ? 2 : 1;

                        const pool = Object.keys(UNIT_DATA).filter(n => UNIT_DATA[n].tier === tier && this.unitPool[n] > 0);
                        if (pool.length === 0) continue;

                        const pickName = pool[Math.floor(Math.random() * pool.length)];
                        const cost = UNIT_DATA[pickName].cost * Math.pow(3, star - 1);

                        if (this.botGold < cost) continue;

                        let shouldBuy = false;
                        const traitsMap = updateTraits();

                        const isUpgrade = this.botUnits.some(u => u.name === pickName);
                        const hasSynergy = UNIT_DATA[pickName].traits.some(t => traitsMap[t] >= 1);
                        const isLateGame = this.botLevel >= 6;
                        const matchesTarget = this.botTargetSynergy && UNIT_DATA[pickName].traits.includes(this.botTargetSynergy);

                        // 0. Target Synergy (Highest Priority in Late Game)
                        if (isLateGame && matchesTarget) shouldBuy = true;

                        // 1. Upgrade?
                        if (!shouldBuy && isUpgrade) shouldBuy = true;

                        // 2. Synergy? (Prioritize in Late Game)
                        if (!shouldBuy) {
                            if (isLateGame) {
                                // If we have a target, we aggressively skip unrelated low-tier units unless they upgrade
                                if (matchesTarget) shouldBuy = true;
                                else if (hasSynergy && !this.botTargetSynergy) shouldBuy = true; // Fallback if no target yet
                                else if (tier >= 4 && this.botGold > 50) shouldBuy = true;
                            } else {
                                if (hasSynergy) shouldBuy = true;
                            }
                        }

                        // 3. Fill Board (if under level limit)?
                        if (!shouldBuy && this.botUnits.filter(u => !u.isBench).length < this.botLevel) shouldBuy = true;

                        // 4. High Value/Rich? (Early game mainly)
                        if (!shouldBuy && !isLateGame && this.botGold > 40 && tier >= 4 && Math.random() > 0.6) shouldBuy = true;

                        // Check 20G rule again (unless filling board which is critical)
                        // If board is full, be stricter with money
                        if (shouldBuy && this.botUnits.length >= this.botLevel) {
                            if (this.botGold - cost < 20) shouldBuy = false;
                        }

                        if (shouldBuy && this.botBench.indexOf(null) !== -1) {
                            this.botGold -= cost;
                            this.unitPool[pickName] -= Math.pow(3, star - 1);
                            const u = new Unit(Date.now() + Math.random(), pickName, UNIT_DATA[pickName], 'enemy');
                            u.owner = 'bot';
                            if (star > 1) { for (let k = 1; k < star; k++) u.upgrade(); u.isUpgrading = false; }

                            this.botUnits.push(u);
                            const bIdx = this.botBench.indexOf(null);
                            this.botBench[bIdx] = u; u.isBench = true; u.row = -1; u.col = -1;

                            this.checkUpgrade(pickName, 'bot');
                        }
                    }

                    // --- Deployment ---
                    // Reset board
                    for (let r = 0; r < 4; r++) for (let c = 0; c < 7; c++) this.botBoard[r][c] = null;
                    this.botBench.fill(null);

                    // Sort by Star > Cost
                    const sorted = [...this.botUnits].sort((a, b) => (b.starLevel * 10 + b.cost) - (a.starLevel * 10 + a.cost));
                    const deployCount = Math.min(sorted.length, this.botLevel);

                    const toDeploy = sorted.slice(0, deployCount);
                    const toBench = sorted.slice(deployCount);

                    toDeploy.forEach(u => {
                        u.currentHp = u.maxHp;
                        u.isBench = false;
                        const isFront = u.type === 'tank' || u.type === 'fighter';
                        const rows = isFront ? [3, 2, 1, 0] : [0, 1, 2, 3];
                        let placed = false;
                        for (let r of rows) {
                            for (let c of [3, 2, 4, 1, 5, 0, 6]) {
                                if (!this.botBoard[r][c]) {
                                    this.botBoard[r][c] = u; u.row = r; u.col = c;
                                    placed = true;
                                    break;
                                }
                            }
                            if (placed) break;
                        }
                        if (!placed) { u.isBench = true; toBench.push(u); }
                    });

                    toBench.forEach((u, i) => {
                        if (i < 9) {
                            this.botBench[i] = u; u.isBench = true; u.row = -1; u.col = -1;
                        } else {
                            this.botGold += u.cost * u.starLevel;
                            this.removeUnit(u, 'bot');
                        }
                    });
                }



                startCombat() {
                    if (this.phase === 'combat') return;

                    // Final check for upgrades and synergies before combat
                    this.checkAllUpgrades('player');
                    this.botItemLogic(); // BOT Item Optimize

                    // Apply Thief's Gloves (After bot equips them)
                    this.applyThiefGloves();

                    updateUI();

                    if (this.board.flat().filter(u => u).length === 0) { showToast(""); return; }
                    this.phase = 'combat';
                    this.combatTime = 0;
                    this.applyAugmentStats(); // Apply augment and item stats before combat
                    this.applySynergyBonuses('player'); // Apply synergy bonuses
                    this.applySynergyBonuses('bot');

                    // Apply item HP bonuses to maxHp
                    [...this.playerUnits, ...this.botUnits].forEach(u => {
                        if (u.isBench) return;
                        let itemHp = 0;
                        const allItems = [...(u.items || []), ...(u.thiefItems || [])];

                        allItems.forEach(it => {
                            let stats = null;
                            let effect = null;
                            if (typeof it === 'number' && BASE_ITEMS[it]) stats = BASE_ITEMS[it].stats;
                            else if (typeof it === 'string' && ITEM_RECIPES[it]) {
                                stats = ITEM_RECIPES[it].stats;
                                effect = ITEM_RECIPES[it].effect;
                            }
                            if (stats && stats.hp) itemHp += stats.hp;
                        });

                        if (itemHp > 0) {
                            u.maxHp += itemHp;
                            u.currentHp += itemHp;
                        }

                        // Item-specific combat start effects
                        const hasItemEffect = (eff) => allItems.some(it => typeof it === 'string' && ITEM_RECIPES[it]?.effect === eff);

                        // Crownguard: Start shield (300)
                        if (hasItemEffect('crownguard')) {
                            u.shield = (u.shield || 0) + 300;
                        }

                        // Protector's Vow: +30 starting mana
                        if (hasItemEffect('protector')) {
                            u.mana = Math.min(u.maxMana, u.mana + 30);
                        }

                        // Blue Buff: -10 max mana (effective)
                        if (hasItemEffect('blue_buff')) {
                            u.blueBuff = true;
                        }

                        // RFC: +1 range
                        if (hasItemEffect('rfc')) {
                            u.stats.range = (u.stats.range || 1) + 1;
                        }

                        // QSS: CC immune
                        if (hasItemEffect('qss')) {
                            u.ccImmune = true;
                        }

                        // Redemption: flag for AOE heal
                        if (hasItemEffect('redemption')) {
                            u.hasRedemption = true;
                        }

                        // Sunfire Cape: flag for burn aura
                        if (hasItemEffect('sunfire')) {
                            u.hasSunfire = true;
                        }

                        // Bramble Vest: flag for crit block
                        if (hasItemEffect('bramble')) {
                            u.hasBramble = true;
                        }
                    });

                    // --- AUGMENT START COMBAT EFFECTS ---
                    // s_bench: Boost based on bench count
                    const benchPowerVal = this.getAugmentValue('bench_power');
                    if (benchPowerVal > 0) {
                        const benchCount = this.playerUnits.filter(u => u.isBench).length;
                        const boost = benchCount * benchPowerVal; // e.g. 5 * 5 = 25 AD/AP
                        if (boost > 0) {
                            this.playerUnits.forEach(u => {
                                if (!u.isBench) {
                                    u.synergyBonuses.ad += boost;
                                    u.synergyBonuses.ap += boost;
                                }
                            });
                            showToast(`: AD/AP+${boost} (${benchCount})`);
                        }
                    }

                    // s_prep: Team start shield
                    const teamShieldPct = this.getAugmentValue('team_start_shield');
                    if (teamShieldPct > 0) {
                        this.playerUnits.forEach(u => {
                            if (!u.isBench) {
                                const val = Math.floor(u.maxHp * (teamShieldPct / 100));
                                u.shield = (u.shield || 0) + val;
                            }
                        });
                        // showToast(`: +${teamShieldPct}%`); // Optional toast
                    }

                    // Shift ALL player units (including summons) to global grid rows 4-7
                    this.playerUnits.forEach(u => {
                        if (!u.isBench) {
                            u.savePos();
                            u.row += 4;
                        }
                    });
                    // Bot units stay at global grid rows 0-3, just save their positions
                    this.botUnits.forEach(u => { if (!u.isBench) u.savePos(); });
                    document.getElementById('btn-start').disabled = true;
                    this.combatInterval = setInterval(() => this.combatTick(), 600);
                }

                applyThiefGloves() {
                    const units = [...this.playerUnits, ...this.botUnits];
                    const completedItemIds = Object.keys(ITEM_RECIPES).filter(id => id.includes('-'));
                    units.forEach(u => {
                        if (u.items && u.items.includes('8-8')) { // 8-8 is Thief's Gloves
                            u.thiefItems = [];
                            for (let i = 0; i < 2; i++) {
                                u.thiefItems.push(completedItemIds[Math.floor(Math.random() * completedItemIds.length)]);
                            }
                            showToast(`${u.name}: `);
                        }
                    });
                }

                applySynergyBonuses(owner) {
                    const units = owner === 'player' ? this.playerUnits.filter(u => !u.isBench) : this.botUnits.filter(u => !u.isBench);
                    const augList = owner === 'player' ? this.augments : (this.botAugments || []);
                    const getAugVal = (eff) => augList.filter(a => a.effect === eff).reduce((sum, a) => sum + a.value, 0);

                    if (units.length === 0) return;

                    // 1. Calculate Trait Counts (Unique by Unit Name, merging traits from items)
                    const traitSet = {};
                    const processUnit = (u) => {
                        let traits = [...u.traits];
                        if (u.items) {
                            u.items.forEach(it => {
                                let rec = null;
                                if (typeof it === 'string' && ITEM_RECIPES[it]) rec = ITEM_RECIPES[it];
                                else if (typeof it === 'object') rec = it; // Fallback
                                if (rec && rec.type === 'trait' && rec.traits) {
                                    traits.push(...rec.traits);
                                }
                            });
                        }
                        // Add Thief Items traits
                        if (u.thiefItems) {
                            u.thiefItems.forEach(itId => {
                                const rec = ITEM_RECIPES[itId];
                                if (rec && rec.traits) traits.push(...rec.traits);
                            });
                        }
                        traits.forEach(t => {
                            if (!traitSet[t]) traitSet[t] = new Set();
                            traitSet[t].add(u.name);
                        });
                    };
                    units.forEach(u => processUnit(u));

                    const cts = {};
                    for (let t in traitSet) cts[t] = traitSet[t].size;

                    // 2. Add Extra Synergies from Augments (Flag-based)
                    const extra = owner === 'player' ? this.extraSynergies : this.botExtraSynergies;
                    if (extra) {
                        Object.keys(extra).forEach(k => {
                            cts[k] = (cts[k] || 0) + extra[k];
                        });
                    }

                    // 3. Apply Bonuses
                    units.forEach(u => {
                        u.synergyBonuses = { hp: 0, ad: 0, ap: 0, armor: 0, mr: 0, crit: 0, range: 0, attackSpeed: 0 };
                    });

                    // Tank synergy
                    const tankCount = cts['Tank'] || 0;
                    if (tankCount >= 6) { units.forEach(u => { u.synergyBonuses.hp += 800; u.synergyBonuses.armor += 40; }); }
                    else if (tankCount >= 4) { units.forEach(u => { u.synergyBonuses.hp += 450; u.synergyBonuses.armor += 20; }); }
                    else if (tankCount >= 2) { units.forEach(u => { u.synergyBonuses.hp += 200; }); }

                    // Warrior synergy
                    const warriorCount = cts['Warrior'] || 0;
                    if (warriorCount >= 8) { units.filter(u => u.traits.includes('Warrior')).forEach(u => { u.synergyBonuses.ad += u.getStat('ad'); u.synergyBonuses.armorPen = 1.0; }); }
                    else if (warriorCount >= 6) { units.filter(u => u.traits.includes('Warrior')).forEach(u => { u.synergyBonuses.ad += Math.floor(u.getStat('ad') * 0.6); }); }
                    else if (warriorCount >= 4) { units.filter(u => u.traits.includes('Warrior')).forEach(u => { u.synergyBonuses.ad += Math.floor(u.getStat('ad') * 0.35); }); }
                    else if (warriorCount >= 2) { units.filter(u => u.traits.includes('Warrior')).forEach(u => { u.synergyBonuses.ad += Math.floor(u.getStat('ad') * 0.15); }); }

                    // Mage synergy
                    const mageCount = cts['Mage'] || 0;
                    if (mageCount >= 6) { units.filter(u => u.traits.includes('Mage')).forEach(u => { u.synergyBonuses.ap += 100; }); }
                    else if (mageCount >= 4) { units.filter(u => u.traits.includes('Mage')).forEach(u => { u.synergyBonuses.ap += 50; }); }
                    else if (mageCount >= 2) { units.filter(u => u.traits.includes('Mage')).forEach(u => { u.synergyBonuses.ap += 20; }); }

                    // Assassin synergy
                    const assassinCount = cts['Assassin'] || 0;
                    if (assassinCount >= 8) { units.filter(u => u.traits.includes('Assassin')).forEach(u => { u.synergyBonuses.crit += 100; u.synergyBonuses.critDamage = 1.0; }); }
                    else if (assassinCount >= 6) { units.filter(u => u.traits.includes('Assassin')).forEach(u => { u.synergyBonuses.crit += 50; u.synergyBonuses.critDamage = 0.5; }); }
                    else if (assassinCount >= 4) { units.filter(u => u.traits.includes('Assassin')).forEach(u => { u.synergyBonuses.crit += 30; u.synergyBonuses.critDamage = 0.25; }); }
                    else if (assassinCount >= 2) { units.filter(u => u.traits.includes('Assassin')).forEach(u => { u.synergyBonuses.crit += 15; }); }

                    // Beast synergy
                    const beastCount = cts['Beast'] || 0;
                    if (beastCount >= 6) { units.filter(u => u.traits.includes('Beast')).forEach(u => { u.synergyBonuses.attackSpeed += 0.5; }); }
                    else if (beastCount >= 4) { units.filter(u => u.traits.includes('Beast')).forEach(u => { u.synergyBonuses.attackSpeed += 0.3; }); }
                    else if (beastCount >= 2) { units.filter(u => u.traits.includes('Beast')).forEach(u => { u.synergyBonuses.attackSpeed += 0.15; }); }

                    // Sniper synergy
                    const sniperCount = cts['Sniper'] || 0;
                    if (sniperCount >= 6) { units.filter(u => u.traits.includes('Sniper')).forEach(u => { u.synergyBonuses.range += 3; u.synergyBonuses.distDamage = 0.10; }); }
                    else if (sniperCount >= 4) { units.filter(u => u.traits.includes('Sniper')).forEach(u => { u.synergyBonuses.range += 2; u.synergyBonuses.distDamage = 0.05; }); }
                    else if (sniperCount >= 2) { units.filter(u => u.traits.includes('Sniper')).forEach(u => { u.synergyBonuses.range += 1; }); }

                    // Cosmic synergy (11 levels)
                    const cosmicCount = cts['Cosmic'] || 0;
                    const cosmicBonuses = [
                        { hp: 0, armor: 0 }, { hp: 50, armor: 0 }, { hp: 100, armor: 5 }, { hp: 200, armor: 10 },
                        { hp: 300, armor: 15 }, { hp: 400, armor: 20 }, { hp: 500, armor: 25 }, { hp: 600, armor: 30 },
                        { hp: 800, armor: 40 }, { hp: 1000, armor: 50 }, { hp: 1500, armor: 70 }, { hp: 2000, armor: 100 }
                    ];
                    const cosmicIdx = Math.min(cosmicCount, 11);
                    if (cosmicCount >= 2) {
                        units.forEach(u => {
                            u.synergyBonuses.hp += cosmicBonuses[cosmicIdx].hp;
                            u.synergyBonuses.armor += cosmicBonuses[cosmicIdx].armor;
                        });
                    }

                    // Epoch synergy - XP bonus handled in endCombat
                    // (stored in synergyBonuses for reference)
                    const epochCount = cts['Epoch'] || 0;
                    if (epochCount >= 3) { units.forEach(u => { u.synergyBonuses.epochXp = 10; }); }
                    else if (epochCount >= 2) { units.forEach(u => { u.synergyBonuses.epochXp = 4; }); }

                    // Pyro synergy - burn damage stored for combatTick
                    const pyroCount = cts['Pyro'] || 0;
                    if (pyroCount >= 5) { units.forEach(u => { u.synergyBonuses.pyroDamage = 120; }); }
                    else if (pyroCount >= 3) { units.forEach(u => { u.synergyBonuses.pyroDamage = 60; }); }
                    else if (pyroCount >= 2) { units.forEach(u => { u.synergyBonuses.pyroDamage = 30; }); }

                    // Cyber synergy
                    const cyberCount = cts['Cyber'] || 0;
                    if (cyberCount >= 6) {
                        units.forEach(u => { u.synergyBonuses.hp += 800; u.synergyBonuses.armor += 30; });
                    } else if (cyberCount >= 4) {
                        units.forEach(u => { u.synergyBonuses.hp += 400; });
                    } else if (cyberCount >= 2) {
                        units.filter(u => u.items && u.items.length > 0).forEach(u => { u.synergyBonuses.hp += 200; });
                    }

                    // Light synergy - death heal stored for combatTick
                    const lightCount = cts['Light'] || 0;
                    if (lightCount >= 8) { units.forEach(u => { u.synergyBonuses.lightHeal = 600; u.synergyBonuses.lightImmune = true; }); }
                    else if (lightCount >= 6) { units.forEach(u => { u.synergyBonuses.lightHeal = 600; u.synergyBonuses.lightShield = true; }); }
                    else if (lightCount >= 4) { units.forEach(u => { u.synergyBonuses.lightHeal = 400; }); }
                    else if (lightCount >= 2) { units.forEach(u => { u.synergyBonuses.lightHeal = 200; }); }

                    // Machine synergy
                    const machineCount = cts['Machine'] || 0;
                    if (machineCount >= 6) {
                        units.filter(u => u.traits.includes('Machine')).forEach(u => {
                            u.synergyBonuses.hp += Math.floor(u.maxHp * 0.6);
                            u.synergyBonuses.ad += Math.floor(u.getStat('ad') * 0.6);
                            u.synergyBonuses.armor += Math.floor(u.getStat('armor') * 0.6);
                        });
                    } else if (machineCount >= 4) {
                        units.filter(u => u.traits.includes('Machine')).forEach(u => {
                            u.synergyBonuses.hp += Math.floor(u.maxHp * 0.3);
                            u.synergyBonuses.ad += Math.floor(u.getStat('ad') * 0.3);
                            u.synergyBonuses.armor += Math.floor(u.getStat('armor') * 0.3);
                        });
                    } else if (machineCount >= 2) {
                        units.filter(u => u.traits.includes('Machine')).forEach(u => { u.synergyBonuses.armor += 20; });
                    }

                    // Dragon synergy
                    const dragonCount = cts['Dragon'] || 0;
                    if (dragonCount >= 2) { units.filter(u => u.traits.includes('Dragon')).forEach(u => { u.synergyBonuses.ap += 50; u.synergyBonuses.dragonAoe = true; }); }
                    else if (dragonCount >= 1) { units.filter(u => u.traits.includes('Dragon')).forEach(u => { u.synergyBonuses.ap += 50; }); }

                    // Enchanter synergy
                    const enchanterCount = cts['Enchanter'] || 0;
                    if (enchanterCount >= 6) {
                        units.forEach(u => { u.synergyBonuses.mr += 50; u.synergyBonuses.healBonus = 0.6; u.synergyBonuses.startShield = Math.floor(u.maxHp * 0.2); });
                    } else if (enchanterCount >= 4) {
                        units.forEach(u => { u.synergyBonuses.mr += 30; u.synergyBonuses.healBonus = 0.4; });
                    } else if (enchanterCount >= 2) {
                        units.forEach(u => { u.synergyBonuses.healBonus = 0.2; });
                    }

                    // Scholar synergy - mana per tick stored
                    const scholarCount = cts['Scholar'] || 0;
                    if (scholarCount >= 6) { units.forEach(u => { u.synergyBonuses.manaPerTick = 20; }); }
                    else if (scholarCount >= 4) { units.forEach(u => { u.synergyBonuses.manaPerTick = 10; }); }
                    else if (scholarCount >= 2) { units.forEach(u => { u.synergyBonuses.manaPerTick = 5; }); }

                    // Void synergy - armor/mr penetration (stored for damage calculation)
                    const voidCount = cts['Void'] || 0;
                    if (voidCount >= 6) { units.forEach(u => { u.synergyBonuses.armorPen = 0.50; u.synergyBonuses.trueDamagePct = 0.10; }); }
                    else if (voidCount >= 4) { units.forEach(u => { u.synergyBonuses.armorPen = 0.30; }); }
                    else if (voidCount >= 2) { units.forEach(u => { u.synergyBonuses.armorPen = 0.15; }); }

                    // Apply HP bonuses
                    units.forEach(u => {
                        const hpBonus = u.synergyBonuses.hp;
                        if (hpBonus > 0) {
                            u.maxHp += hpBonus;
                            u.currentHp += hpBonus;
                        }
                        // Apply start shield from Enchanter
                        if (u.synergyBonuses.startShield) {
                            u.shield = (u.shield || 0) + u.synergyBonuses.startShield;
                        }
                    });
                }

                countTrait(owner, trait) {
                    const units = owner === 'player' ? this.playerUnits.filter(u => !u.isBench) : this.botUnits.filter(u => !u.isBench);
                    const unq = new Map(); units.forEach(u => unq.set(u.name, u));
                    let count = 0;
                    unq.forEach(u => { if (u.traits && u.traits.includes(trait)) count++; });
                    return count;
                }

                combatTick() {
                    this.combatTime++;
                    const pUnits = this.playerUnits.filter(u => !u.isBench && u.currentHp > 0);
                    const eUnits = this.botUnits.filter(u => !u.isBench && u.currentHp > 0);

                    if (pUnits.length === 0 || eUnits.length === 0 || this.combatTime > 100) {
                        this.endCombat(pUnits.length, eUnits.length); return;
                    }

                    const allUnits = [...pUnits, ...eUnits];

                    // === STATUS EFFECT DURATION CHECK ===
                    allUnits.forEach(u => {
                        // Check if stun/freeze has expired
                        if (u.stunEndTick && this.combatTime >= u.stunEndTick) {
                            u.isStunned = false;
                            u.isFrozen = false;
                            u.stunEndTick = 0;
                        }
                        // Check if invulnerability has expired
                        if (u.invulnEndTick && this.combatTime >= u.invulnEndTick) {
                            u.isInvulnerable = false;
                            u.invulnEndTick = 0;
                        }
                    });

                    // === ITEM TICK EFFECTS ===
                    allUnits.forEach(u => {
                        if (u.currentHp <= 0) return;

                        // Sunfire Cape: burn nearby enemies
                        if (u.hasSunfire) {
                            const enemies = u.owner === 'player' ? eUnits : pUnits;
                            const nearby = enemies.filter(e => {
                                const dist = Math.abs(u.row - e.row) + Math.abs(u.col - e.col);
                                return dist <= 2 && e.currentHp > 0;
                            });
                            nearby.forEach(e => {
                                const burnDmg = Math.ceil(e.maxHp * 0.01); // 1% max HP per tick
                                e.takeDamage(burnDmg, 'true');
                                e.isBurning = true;
                            });
                        }

                        // Archangel's Staff: +20 AP every 5 ticks (~ every 3 seconds)
                        const hasArchangel = [...(u.items || []), ...(u.thiefItems || [])].some(it => it === '3-4');
                        if (hasArchangel && this.combatTime % 5 === 0) {
                            u.archangelStacks = (u.archangelStacks || 0) + 20;
                        }

                        // Redemption: AOE heal every 8 ticks (~5 seconds)
                        if (u.hasRedemption && this.combatTime % 8 === 0) {
                            const allies = u.owner === 'player' ? pUnits : eUnits;
                            allies.forEach(a => {
                                if (a.currentHp > 0 && a.heal) {
                                    a.heal(150);
                                }
                            });
                        }

                        // Nashor's Tooth: bonus AS after skill use
                        const hasNashor = [...(u.items || []), ...(u.thiefItems || [])].some(it => it === '2-7');
                        if (hasNashor && u.skillUsed && !u.nashorApplied) {
                            u.tempAttackSpeed = (u.tempAttackSpeed || 0) + 0.5;
                            u.nashorApplied = true;
                        }

                        // Titan's Resolve: gain armor/mr when hit (tracked via titanStacks)
                        const hasTitan = [...(u.items || []), ...(u.thiefItems || [])].some(it => it === '2-5');
                        if (hasTitan) {
                            // Checked on damage, stacks applied there
                        }

                        // Gargoyle Stoneplate: +15 armor/mr per enemy targeting
                        const hasGargoyle = [...(u.items || []), ...(u.thiefItems || [])].some(it => it === '5-6');
                        if (hasGargoyle) {
                            const enemies = u.owner === 'player' ? eUnits : pUnits;
                            const targeting = enemies.filter(e => e.currentHp > 0).length;
                            u.gargoyleBonus = targeting * 15;
                        }
                    });

                    // === SYNERGY TICK EFFECTS ===

                    // Scholar mana regen
                    allUnits.forEach(u => {
                        if (u.synergyBonuses && u.synergyBonuses.manaPerTick) {
                            u.mana = Math.min(u.maxMana, u.mana + u.synergyBonuses.manaPerTick);
                        }
                    });

                    // Pyro burn damage to enemies
                    const playerPyro = pUnits.find(u => u.synergyBonuses && u.synergyBonuses.pyroDamage);
                    if (playerPyro) {
                        const pyroDmg = playerPyro.synergyBonuses.pyroDamage;
                        eUnits.forEach(e => {
                            e.takeDamage(pyroDmg, 'true');
                            e.isBurning = true;
                        });
                    }
                    const botPyro = eUnits.find(u => u.synergyBonuses && u.synergyBonuses.pyroDamage);
                    if (botPyro) {
                        const pyroDmg = botPyro.synergyBonuses.pyroDamage;
                        pUnits.forEach(p => {
                            p.takeDamage(pyroDmg, 'true');
                            p.isBurning = true;
                        });
                    }

                    // Light synergy - check for deaths and heal allies
                    allUnits.forEach(u => {
                        if (u.currentHp <= 0 && !u.lightTriggered && u.synergyBonuses && u.synergyBonuses.lightHeal) {
                            u.lightTriggered = true;
                            const allies = u.owner === 'player' ? pUnits : eUnits;
                            const healAmt = u.synergyBonuses.lightHeal;
                            allies.filter(a => a.currentHp > 0).forEach(a => {
                                if (a.heal) a.heal(healAmt);
                                else a.currentHp = Math.min(a.maxHp, a.currentHp + healAmt);
                            });
                        }
                    });

                    // === AUGMENT TICK EFFECTS ===

                    // Second Wind - 1017tickHP
                    const secondWindVal = this.getAugmentValue('second_wind');
                    if (secondWindVal > 0 && this.combatTime === 17) {
                        pUnits.forEach(u => {
                            const healAmt = Math.ceil(u.maxHp * (secondWindVal / 100));
                            if (u.heal) u.heal(healAmt);
                            else u.currentHp = Math.min(u.maxHp, u.currentHp + healAmt);
                        });
                        showToast(` HP${secondWindVal}%`);
                    }

                    // Ascension - 1525tick+50%
                    const ascensionVal = this.getAugmentValue('ascension');
                    if (ascensionVal > 0 && this.combatTime === 25 && !this.ascensionTriggered) {
                        this.ascensionTriggered = true;
                        pUnits.forEach(u => {
                            u.ascensionBonus = ascensionVal / 100;
                        });
                        showToast(` +${ascensionVal}%`);
                    }

                    // Start Reduce - 23tick
                    const startReduceVal = this.getAugmentValue('start_reduce');
                    if (startReduceVal > 0 && this.combatTime <= 3) {
                        pUnits.forEach(u => {
                            u.damageReduction = startReduceVal / 100;
                        });
                    } else if (startReduceVal > 0 && this.combatTime === 4) {
                        pUnits.forEach(u => {
                            u.damageReduction = 0;
                        });
                    }

                    // Helper to check 8x7 grid
                    const getUnitAt = (r, c) => {
                        if (r < 0 || r > 7 || c < 0 || c > 6) return null;
                        if (r < 4) return this.botBoard[r][c];
                        return this.board[r - 4][c];
                    };
                    const setUnitAt = (r, c, u) => {
                        if (r < 4) this.botBoard[r][c] = u;
                        else this.board[r - 4][c] = u;
                    };

                    // Combat Logic: Attack & Move
                    allUnits.forEach(u => {
                        if (u.currentHp <= 0) return;
                        // Stunned/Frozen units cannot act
                        if (u.isStunned || u.isFrozen) return;

                        const enemyPool = u.owner === 'player' ? eUnits : pUnits;
                        const target = enemyPool.sort((a, b) => {
                            const distA = Math.abs(u.row - a.row) + Math.abs(u.col - a.col);
                            const distB = Math.abs(u.row - b.row) + Math.abs(u.col - b.col);
                            return distA - distB;
                        })[0];

                        if (target) {
                            const dist = Math.abs(u.row - target.row) + Math.abs(u.col - target.col);
                            if (dist <= u.getStat('range')) {
                                // Skill check
                                if (u.mana >= u.maxMana) {
                                    u.castSkill(enemyPool, this);
                                    // Blue Buff: restore 20 mana after skill
                                    if (u.blueBuff) {
                                        u.mana = 20;
                                    }
                                } else {
                                    // Normal attack - AP or AD based on unit type
                                    const isAPUnit = u.type === 'mage' || u.type === 'enchanter';
                                    const critChance = u.getStat('crit') / 100;
                                    let isCrit = Math.random() < critChance;
                                    let mult = isCrit ? (1.5 + (u.synergyBonuses.critDamage || 0)) : 1.0;

                                    // Sniper distance bonus
                                    if (u.synergyBonuses.distDamage) {
                                        mult *= (1 + dist * u.synergyBonuses.distDamage);
                                    }

                                    // Giant Slayer: +25% damage vs HP 1600+
                                    const hasGiantSlayer = [...(u.items || []), ...(u.thiefItems || [])].some(it => it === '1-2');
                                    if (hasGiantSlayer && target.maxHp >= 1600) {
                                        mult *= 1.25;
                                    }

                                    let finalDam;
                                    let dmgType;
                                    if (isAPUnit) {
                                        // AP-based attack
                                        const rawDam = u.getStat('ap') || 100;
                                        const pen = u.synergyBonuses.magicPen || 0; // Future magic pen support
                                        const red = 100 / (100 + Math.max(0, target.getStat('mr') * (1 - pen)));
                                        finalDam = Math.ceil(rawDam * 0.5 * mult * red);
                                        dmgType = isCrit ? 'crit' : 'ap';
                                    } else {
                                        // AD-based attack
                                        const rawDam = u.getStat('ad');
                                        const pen = u.synergyBonuses.armorPen || 0;
                                        const red = 100 / (100 + Math.max(0, target.getStat('armor') * (1 - pen)));
                                        finalDam = Math.ceil(rawDam * mult * red);
                                        dmgType = isCrit ? 'crit' : 'ad';
                                    }
                                    // Bramble Vest: block crits and reflect damage
                                    if (target.hasBramble && isCrit) {
                                        isCrit = false;
                                        mult = 1.0; // Remove crit bonus
                                        // Recalculate damage
                                        if (isAPUnit) {
                                            const rawDam = u.getStat('ap') || 100;
                                            const red = 100 / (100 + Math.max(0, target.getStat('mr')));
                                            finalDam = Math.ceil(rawDam * 0.5 * mult * red);
                                        } else {
                                            const rawDam = u.getStat('ad');
                                            const pen = u.synergyBonuses.armorPen || 0;
                                            const red = 100 / (100 + Math.max(0, target.getStat('armor') * (1 - pen)));
                                            finalDam = Math.ceil(rawDam * mult * red);
                                        }
                                        // Reflect damage
                                        const reflectDmg = Math.ceil(finalDam * 0.25);
                                        u.takeDamage(reflectDmg, 'true');
                                    }

                                    // Titan's Resolve: target gains stacks when hit
                                    const targetHasTitan = [...(target.items || []), ...(target.thiefItems || [])].some(it => it === '2-5');
                                    if (targetHasTitan) {
                                        target.titanStacks = Math.min(25, (target.titanStacks || 0) + 1);
                                    }

                                    // Apply damage to shield first, then HP
                                    let shieldDamage = 0;
                                    if (target.shield && target.shield > 0) {
                                        if (target.shield >= finalDam) {
                                            shieldDamage = finalDam;
                                            target.shield -= finalDam;
                                            finalDam = 0;
                                        } else {
                                            shieldDamage = target.shield;
                                            finalDam -= target.shield;
                                            target.shield = 0;
                                        }
                                        if (shieldDamage > 0) {
                                            showDamage(target, shieldDamage, 'shield');
                                        }
                                    }

                                    if (finalDam > 0) {
                                        target.currentHp -= finalDam;
                                        showDamage(target, finalDam, dmgType);
                                    }

                                    // True Damage (Void synergy)
                                    if (u.synergyBonuses.trueDamagePct) {
                                        const trueDam = Math.ceil(finalDam * u.synergyBonuses.trueDamagePct);
                                        if (trueDam > 0) {
                                            target.takeDamage(trueDam, 'true');
                                        }
                                    }

                                    u.addMana(10); target.addMana(5);

                                    // === ITEM EFFECTS ON ATTACK ===
                                    const hasItem = (itemId) => {
                                        const items = [...(u.items || []), ...(u.thiefItems || [])];
                                        return items.some(it => {
                                            if (typeof it === 'string') return it === itemId;
                                            if (typeof it === 'object' && it) return it.id === itemId;
                                            return false;
                                        });
                                    };

                                    // Shojin: +5 mana on attack
                                    if (hasItem('1-4')) u.addMana(5);

                                    // Guinsoo: +5% AS on attack (stacking)
                                    if (hasItem('2-3')) {
                                        u.guinsooStacks = (u.guinsooStacks || 0) + 1;
                                        u.tempAttackSpeed = (u.tempAttackSpeed || 0) + 0.05;
                                    }

                                    // Statikk Shiv: every 3rd attack, magic damage to nearby enemies
                                    if (hasItem('2-4')) {
                                        u.statikkCounter = (u.statikkCounter || 0) + 1;
                                        if (u.statikkCounter >= 3) {
                                            u.statikkCounter = 0;
                                            const shivDmg = 80;
                                            const nearby = enemyPool.slice(0, 3);
                                            nearby.forEach(e => {
                                                if (e.currentHp > 0) {
                                                    e.takeDamage(shivDmg, 'ap');
                                                }
                                            });
                                        }
                                    }

                                    // Runaan's Hurricane: 50% damage to nearby enemy
                                    if (hasItem('2-6')) {
                                        const secondary = enemyPool.filter(e => e !== target && e.currentHp > 0)[0];
                                        if (secondary) {
                                            const runaanDmg = Math.ceil(finalDam * 0.5);
                                            secondary.takeDamage(runaanDmg, dmgType);
                                        }
                                    }

                                    // Last Whisper: reduce armor by 50% for 3 ticks
                                    if (hasItem('2-8') && isCrit) {
                                        target.armorShred = 0.5;
                                        target.armorShredEnd = this.combatTime + 3;
                                    }

                                    // Bloodthirster / Hextech Gunblade: lifesteal
                                    const vampItems = ['1-6', '1-3'];
                                    let vampPct = 0;
                                    vampItems.forEach(id => { if (hasItem(id)) vampPct += 0.2; });
                                    if (vampPct > 0) {
                                        const healAmt = Math.ceil(finalDam * vampPct);
                                        if (u.heal) u.heal(healAmt);
                                    }

                                    // Giant Slayer: +25% damage vs HP 1600+
                                    // (already applied via mult, but let's add check)

                                    // Dark synergy lifesteal
                                    if (u.traits && u.traits.includes('Dark')) {
                                        let lifestealPct = 0;
                                        const darkCount = this.countTrait(u.owner, 'Dark');
                                        if (darkCount >= 6) lifestealPct = 0.5;
                                        else if (darkCount >= 4) lifestealPct = 0.3;
                                        else if (darkCount >= 2) lifestealPct = 0.15;

                                        if (lifestealPct > 0) {
                                            const healAmt = Math.ceil(finalDam * lifestealPct);
                                            if (u.heal) u.heal(healAmt);
                                        }
                                    }

                                    // Frost synergy freeze
                                    if (u.traits && u.traits.includes('Frost') && !target.isFrozen) {
                                        let freezeChance = 0;
                                        let freezeTicks = 2;
                                        const frostCount = this.countTrait(u.owner, 'Frost');
                                        if (frostCount >= 6) { freezeChance = 1.0; freezeTicks = 4; }
                                        else if (frostCount >= 4) { freezeChance = 0.4; freezeTicks = 3; }
                                        else if (frostCount >= 2) { freezeChance = 0.2; freezeTicks = 2; }

                                        if (Math.random() < freezeChance) {
                                            target.isFrozen = true;
                                            target.isStunned = true;
                                            target.stunEndTick = this.combatTime + freezeTicks;
                                        }
                                    }

                                    const el = document.querySelector(`.unit[data-id="${u.id}"]`);
                                    if (el) { el.classList.add('attacking'); setTimeout(() => el.classList.remove('attacking'), 300); }
                                }
                            } else {
                                // Movement Logic
                                u.moveWait = (u.moveWait || 0) + 1;
                                const isRanged = u.getStat('range') > 1;
                                if (u.moveWait >= (isRanged ? 2 : 1)) {
                                    u.moveWait = 0;
                                    let bestMove = null, minMoveDist = 999;
                                    const directions = [{ dr: -1, dc: 0 }, { dr: 1, dc: 0 }, { dr: 0, dc: -1 }, { dr: 0, dc: 1 }];
                                    directions.forEach(dir => {
                                        const nr = u.row + dir.dr, nc = u.col + dir.dc;
                                        if (nr >= 0 && nr <= 7 && nc >= 0 && nc <= 6 && !getUnitAt(nr, nc)) {
                                            const d = Math.abs(nr - target.row) + Math.abs(nc - target.col);
                                            if (d < minMoveDist) { minMoveDist = d; bestMove = { r: nr, c: nc }; }
                                        }
                                    });
                                    if (bestMove) { setUnitAt(u.row, u.col, null); u.row = bestMove.r; u.col = bestMove.c; setUnitAt(u.row, u.col, u); }
                                }
                            }
                        }
                    });

                    // --- Live Sync ---
                    for (let r = 0; r < 4; r++) { for (let c = 0; c < 7; c++) { this.board[r][c] = null; this.botBoard[r][c] = null; } }
                    allUnits.forEach(u => { if (u.currentHp > 0 && !u.isBench) setUnitAt(u.row, u.col, u); });

                    updateUI();
                }

                endCombat(pCount, eCount) {
                    clearInterval(this.combatInterval);
                    this.combatInterval = null;

                    // 1. Determine local winner and apply damage immediately
                    if (this.hp > 0 && this.botHp > 0) {
                        if (pCount === 0 && eCount > 0) {
                            this.hp -= eCount * 2;
                            showCombatResult('DEFEAT', `-${eCount * 2} HP`, '#f7768e');
                        }
                        else if (eCount === 0 && pCount > 0) {
                            this.botHp -= pCount * 2;
                            showCombatResult('VICTORY', `-${pCount * 2} HP`, '#9ece6a');
                        }
                        else {
                            showCombatResult('DRAW', '', '#7aa2f7');
                        }
                    }

                    // Check for Game Over immediately
                    if (this.hp <= 0 || this.botHp <= 0) {
                        setTimeout(() => { alert(this.hp <= 0 ? "GameOver" : "YouWin"); location.reload(); }, 1800);
                        return;
                    }

                    // 2. Delay transition logic by 2 seconds to let "Victory" etc. finish displaying
                    setTimeout(() => {
                        this.phase = 'planning';

                        // Cleanup Thief Items
                        [...this.playerUnits, ...this.botUnits].forEach(u => { delete u.thiefItems; });

                        // Streak Logic
                        if (pCount > 0 && eCount === 0) {
                            this.streak = this.streak > 0 ? this.streak + 1 : 1;
                            this.botStreak = this.botStreak < 0 ? this.botStreak - 1 : -1;
                        } else if (eCount > 0 && pCount === 0) {
                            this.streak = this.streak < 0 ? this.streak - 1 : -1;
                            this.botStreak = this.botStreak > 0 ? this.botStreak + 1 : 1;
                        } else {
                            this.streak = 0; this.botStreak = 0;
                        }

                        const maxInterest = Math.max(5, this.getAugmentValue('max_interest'), this.getAugmentValue('eco_combo'));
                        this.interest = Math.floor(Math.min(this.gold, maxInterest * 10) / 10);
                        this.gold += 5 + this.interest + this.getStreakBonus(this.streak);

                        if (eCount > 0) this.gold += this.getAugmentValue('loss_gold');

                        // Metabolic Accelerator
                        const regen = this.getAugmentValue('player_regen');
                        if (regen > 0) { this.hp += regen; showToast(`: HP+${regen}`); }

                        this.xp += 2;
                        const epochUnit = this.playerUnits.find(u => u.synergyBonuses && u.synergyBonuses.epochXp);
                        if (epochUnit) { this.xp += epochUnit.synergyBonuses.epochXp; showToast(`: +${epochUnit.synergyBonuses.epochXp} XP`); }
                        if (this.xp >= (XP_TABLE[this.level] || 999)) { this.xp -= XP_TABLE[this.level]; this.level++; }

                        this.botGold += 5 + Math.floor(Math.min(this.botGold, 50) / 10) + this.getStreakBonus(this.botStreak);
                        this.botXp += 2;
                        if (this.botXp >= (XP_TABLE[this.botLevel] || 999)) { this.botXp -= XP_TABLE[this.botLevel]; this.botLevel++; }

                        this.applyAugmentStats(); // Refresh stats for next round
                        this.stage++;
                        this.round++;

                        // Trade Sector Logic
                        const freeRolls = this.getAugmentValue('free_reroll');
                        if (freeRolls > 0) { this.freeRerolls = freeRolls; showToast(': '); } else { this.freeRerolls = 0; }

                        // Item & Augment Triggers
                        const currentStageNum = Math.floor((this.stage - 1) / 5) + 1;
                        const currentTurnNum = ((this.stage - 1) % 5) + 1;
                        if (currentTurnNum === 1) {
                            if (currentStageNum % 2 === 1 && currentStageNum > 1) {
                                const count = 3 + Math.floor(Math.random() * 3);
                                for (let i = 0; i < count; i++) {
                                    this.giveItem(Math.floor(Math.random() * 10) + 1);
                                    this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                                }
                            }
                            if (currentStageNum % 2 === 0) { this.spawnAugments(); }
                        }
                        if (this.stage === 2) {
                            this.giveItem(Math.floor(Math.random() * 10) + 1);
                            this.botGiveItem(Math.floor(Math.random() * 10) + 1);
                            this.spawnInitialAugment();
                        }

                        // Remove summons from unit lists
                        this.playerUnits = this.playerUnits.filter(u => !u.isSummon);
                        this.botUnits = this.botUnits.filter(u => !u.isSummon);

                        this.board = Array(4).fill(null).map(() => Array(7).fill(null));
                        this.playerUnits.forEach(u => {
                            u.maxHp = u.stats.hp;
                            u.currentHp = u.maxHp;
                            u.mana = 0;
                            u.isFighting = false; u.isDead = false;
                            u.isStunned = false; u.isFrozen = false; u.isBurning = false; u.isInvulnerable = false;
                            u.reflectDamage = 0; u.tempArmor = 0; u.tempAttackSpeed = 0; u.tempAdReduction = 0;
                            u.ascensionBonus = 0; u.damageReduction = 0; u.lightTriggered = false;
                            u.stunEndTick = 0; u.invulnEndTick = 0; u.shield = 0;
                            if (!u.isBench) {
                                u.resetPos();
                                if (u.row >= 0 && u.row < 4 && u.col >= 0 && u.col < 7 && !this.board[u.row][u.col]) this.board[u.row][u.col] = u;
                            }
                        });
                        this.botUnits.forEach(u => {
                            u.maxHp = u.stats.hp; u.currentHp = u.maxHp; u.mana = 0;
                            u.isBench = true; u.row = -1; u.col = -1;
                            u.isStunned = false; u.isFrozen = false; u.isBurning = false; u.isInvulnerable = false;
                            u.reflectDamage = 0; u.tempArmor = 0; u.tempAttackSpeed = 0; u.tempAdReduction = 0;
                            u.ascensionBonus = 0; u.damageReduction = 0; u.lightTriggered = false;
                            u.stunEndTick = 0; u.invulnEndTick = 0; u.shield = 0;
                        });

                        this.fillShop();
                        this.botDeploy();
                        document.getElementById('btn-start').disabled = false;
                        updateUI();
                    }, 2000);
                }

                buyXp() {
                    if (this.gold >= 4 && this.level < 11) {
                        this.gold -= 4; this.xp += 4;
                        if (this.xp >= (XP_TABLE[this.level] || 999)) { this.xp -= XP_TABLE[this.level]; this.level++; }
                        updateUI();
                    }
                }
            }

            // ===== ITEM TOOLTIP HELPERS =====
            function showItemTooltip(item, rect) {
                const tt = document.createElement('div');
                tt.className = 'item-tooltip';
                tt.style.cssText = 'position:fixed;z-index:3000;background:rgba(20,22,35,0.98);border:1px solid #7aa2f7;border-radius:6px;padding:8px;font-size:0.75rem;color:#ccc;pointer-events:none;white-space:pre-wrap;';

                let itemName = '';
                let desc = '';
                let statsStr = '';
                let data = null;

                if (typeof item === 'number') {
                    itemName = BASE_ITEMS[item] ? BASE_ITEMS[item].name : '???';
                    data = BASE_ITEMS[item];
                    if (data) {
                        desc = data.stat;
                        // Add Recipes Preview
                        let recipesHtml = '<div style="margin-top:8px; border-top:1px solid #444; padding-top:4px; font-size:0.65rem; color:#888;"></div><div style="display:grid; grid-template-columns:1fr 1fr; gap:4px; font-size:0.65rem;">';
                        Object.entries(ITEM_RECIPES).forEach(([key, recipe]) => {
                            const parts = key.split('-').map(Number);
                            if (parts.includes(item)) {
                                const other = parts[0] === item ? parts[1] : parts[0];
                                recipesHtml += `<div>${BASE_ITEMS[other] ? `<i class="${BASE_ITEMS[other].icon}"></i>` : '?'}  <i class="${recipe.icon || ''}"></i> ${recipe.name}</div>`;
                            }
                        });
                        recipesHtml += '</div>';
                        desc += recipesHtml;
                    }
                } else if (typeof item === 'string') {
                    itemName = ITEM_RECIPES[item] ? ITEM_RECIPES[item].name : '???';
                    data = ITEM_RECIPES[item];
                    if (data) {
                        desc = data.desc || '';
                        for (let k in data.stats) statsStr += `${k.toUpperCase()}+${data.stats[k]} `;
                    }
                }

                tt.innerHTML = `<div style="color:#ffd700;font-weight:bold;margin-bottom:4px;">${itemName}</div><div style="font-size:0.7rem;margin-bottom:4px;">${desc || ''}</div>${statsStr ? `<div style="color:#7dcfff;">${statsStr}</div>` : ''}`;

                document.body.appendChild(tt);
                const tRect = tt.getBoundingClientRect();
                let left = rect.left;
                let top = rect.top - tRect.height - 10;
                if (top < 0) top = rect.bottom + 10;
                if (left + tRect.width > window.innerWidth) left = window.innerWidth - tRect.width - 10;
                tt.style.left = left + 'px';
                tt.style.top = top + 'px';
            }

            function hideItemTooltip() {
                document.querySelectorAll('.item-tooltip').forEach(e => e.remove());
            }

            // ===== GLOBAL ITEM GUIDE HELPERS =====
            function switchGuideTab(tabName) {
                document.querySelectorAll('.guide-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.guide-content').forEach(c => c.style.display = 'none');

                if (tabName === 'recommended') {
                    document.querySelectorAll('.guide-tab')[0].classList.add('active');
                    document.getElementById('guide-content-recommended').style.display = 'block';
                } else {
                    document.querySelectorAll('.guide-tab')[1].classList.add('active');
                    document.getElementById('guide-content-recipes').style.display = 'block';
                    if (!document.getElementById('guide-content-recipes').hasChildNodes()) {
                        renderAllRecipes();
                    }
                }
            }

            function renderAllRecipes() {
                const container = document.getElementById('guide-content-recipes');
                if (!container) return; // Guard
                container.innerHTML = '';

                for (let i = 1; i <= 10; i++) {
                    const group = document.createElement('div');
                    group.style.marginBottom = '10px';
                    const title = document.createElement('div');
                    title.className = 'guide-section-title';
                    // Check if BASE_ITEMS[i] exists to avoid error
                    if (BASE_ITEMS[i]) {
                        title.innerHTML = `+ ${BASE_ITEMS[i].name} (<i class="${BASE_ITEMS[i].icon}"></i>)`;
                        group.appendChild(title);

                        for (let j = 1; j <= 10; j++) {
                            // Show all combinations for clarity in each section
                            const key = i <= j ? `${i}-${j}` : `${j}-${i}`;
                            const recipe = ITEM_RECIPES[key];
                            if (!recipe) continue;

                            const row = document.createElement('div');
                            row.className = 'rec-row';

                            const iconBox = document.createElement('div');
                            iconBox.className = `item-icon-box mat-${j}`;
                            iconBox.innerHTML = BASE_ITEMS[j] ? `<i class="${BASE_ITEMS[j].icon}"></i>` : '?';

                            const info = document.createElement('div');
                            info.innerHTML = `<div class="rec-name" style="display:flex;align-items:center;gap:4px;"><i class="${recipe.icon || ''}"></i> ${recipe.name}</div><div class="rec-desc">${recipe.desc || ''}</div>`;

                            row.appendChild(iconBox);
                            row.appendChild(info);
                            group.appendChild(row);
                        }
                        container.appendChild(group);
                    }
                }
            }

            function showUnitDetail(u, rect) {
                const box = document.getElementById('unit-detail-box');
                if (!box) return;

                // Content Generation
                let dmgType = '';
                let dmgColor = '#c5a059';
                if (u.type === 'mage' || u.type === 'enchanter') { dmgType = ''; dmgColor = '#4aa3cc'; }

                // Calculate stats
                const hp = u.getStat('hp');
                const ad = u.getStat('ad');
                const ap = u.getStat('ap');
                const armor = u.getStat('armor');
                const mr = u.getStat('mr');
                const as = u.getStat('attackSpeed').toFixed(2);
                const crit = u.getStat('crit');
                const range = u.getStat('range');

                const traitsHtml = u.traits.concat((u.items || []).flatMap(i => {
                    let d = null;
                    if (typeof i === 'string') d = ITEM_RECIPES[i];
                    else if (typeof i === 'number') d = BASE_ITEMS[i];
                    return (d && d.traits) ? d.traits : [];
                })).concat((u.thiefItems || []).flatMap(i => {
                    const d = ITEM_RECIPES[i];
                    return (d && d.traits) ? d.traits : [];
                })).filter((v, i, a) => a.indexOf(v) === i) // unique
                    .map(t => {
                        const synName = SYNERGY_DATA[t] ? SYNERGY_DATA[t].name : t;
                        return `<span class="unit-chip">${synName}</span>`;
                    }).join('');

                box.innerHTML = `
                    <div style="font-weight:bold;color:${u.owner === 'bot' ? '#a65e5e' : '#6b8c73'};margin-bottom:5px;border-bottom:1px solid #4a4036;padding-bottom:2px;">
                        ${u.name} <span style="font-size:0.7rem;color:#ffd700;">${u.starLevel}</span> <span style="font-size:0.7rem;color:#ccc;">${u.cost}G</span>
                    </div>
                    <div class="unit-chips" style="margin-bottom:8px;">${traitsHtml}</div>
                    <div style="display:grid;grid-template-columns:1fr 1fr;gap:2px;font-size:0.7rem;color:#ccc;margin-bottom:8px;">
                        <div>HP: <span style="color:#e6dfcc;">${u.currentHp.toFixed(0)}</span>/<span style="color:#6b8c73;">${u.maxHp}</span>${u.shield > 0 ? ` <span style="color:#fff;">(+${u.shield})</span>` : ''}${u.getStatDetails ? (u.getStatDetails('hp').item + u.getStatDetails('hp').augment + u.getStatDetails('hp').synergy > 0 ? ` <span style="color:#ffd700;">(+${u.getStatDetails('hp').item + u.getStatDetails('hp').augment + u.getStatDetails('hp').synergy})</span>` : '') : ''}</div>
                        <div>Mana: <span style="color:#4aa3cc;">${u.mana.toFixed(0)}</span>/${u.maxMana}</div>
                        <div>AD: <span style="color:#c5a059;">${ad}</span>${u.getStatDetails ? (u.getStatDetails('ad').item + u.getStatDetails('ad').augment > 0 ? ` <span style="color:#ffd700;">(+${u.getStatDetails('ad').item + u.getStatDetails('ad').augment})</span>` : '') : ''}</div>
                        <div>AP: <span style="color:#a34acc;">${ap}</span>${u.getStatDetails ? (u.getStatDetails('ap').item + u.getStatDetails('ap').augment > 0 ? ` <span style="color:#ffd700;">(+${u.getStatDetails('ap').item + u.getStatDetails('ap').augment})</span>` : '') : ''}</div>
                        <div>AR: <span style="color:#8c6e2d;">${armor}</span>${u.getStatDetails ? (u.getStatDetails('armor').item + u.getStatDetails('armor').augment > 0 ? ` <span style="color:#ffd700;">(+${u.getStatDetails('armor').item + u.getStatDetails('armor').augment})</span>` : '') : ''}</div>
                        <div>MR: <span style="color:#4da674;">${mr}</span>${u.getStatDetails ? (u.getStatDetails('mr').item + u.getStatDetails('mr').augment > 0 ? ` <span style="color:#ffd700;">(+${u.getStatDetails('mr').item + u.getStatDetails('mr').augment})</span>` : '') : ''}</div>
                        <div>AS: <span style="color:#b8860b;">${as}</span></div>
                        <div>Crit: <span style="color:#8c4a4a;">${crit}%</span></div>
                        <div>Range: <span>${range}</span></div>
                    </div>
                    <div style="font-size:0.7rem;border-top:1px solid #444;padding-top:4px;">
                        <div style="color:#4aa3cc;font-weight:bold;margin-bottom:2px;">${u.skill.name}</div>
                        <div style="color:#888;line-height:1.2;">${u.skill.desc}</div>
                    </div>
                `;

                if (rect) {
                    // Synergy list hover: position near the cursor
                    let left = rect.right + 10;
                    let top = rect.top;
                    // Boundary check (approx box size 220x300)
                    if (left + 230 > window.innerWidth) left = rect.left - 230;
                    if (top + 320 > window.innerHeight) top = window.innerHeight - 330;
                    if (top < 10) top = 10;
                    if (left < 10) left = 10;

                    box.style.cssText = `display:block;position:fixed;top:${top}px;left:${left}px;width:240px;z-index:2000;background:#2b2520;border:1px solid #c5a059;border-radius:4px;padding:10px;pointer-events:none;color:#d4c5a3;font-family:'Times New Roman',serif;`;
                } else {
                    // Board units: fixed position on the right side
                    box.style.cssText = `display:block;position:fixed;top:120px;right:180px;width:240px;z-index:2000;background:#2b2520;border:1px solid #c5a059;border-radius:4px;padding:10px;pointer-events:none;color:#d4c5a3;font-family:'Times New Roman',serif;`;
                }
            }

            function hideUnitDetail() {
                const box = document.getElementById('unit-detail-box');
                if (box) {
                    // Reset to default fixed position for next display
                    box.style.cssText = `display:none;position:fixed;top:120px;right:180px;width:240px;z-index:2000;background:#2b2520;border:1px solid #c5a059;border-radius:4px;padding:10px;pointer-events:none;color:#d4c5a3;font-family:'Times New Roman',serif;`;
                }
            }

            // Combine Preview for item crafting
            let combinePreviewEl = null;
            function showCombinePreview(recipe, rect) {
                if (!combinePreviewEl) {
                    combinePreviewEl = document.createElement('div');
                    combinePreviewEl.id = 'combine-preview';
                    document.body.appendChild(combinePreviewEl);
                }
                const statsStr = recipe.stats ? Object.entries(recipe.stats).map(([k, v]) => `${k.toUpperCase()}: +${v}`).join(', ') : '';
                combinePreviewEl.innerHTML = `
                    <div style="font-weight:bold;color:#ffd700;margin-bottom:4px;"><i class="${recipe.icon || ''}"></i> ${recipe.name}</div>
                    <div style="font-size:0.7rem;color:#4da674;margin-bottom:2px;">${recipe.desc || ''}</div>
                    <div style="font-size:0.65rem;color:#888;">${statsStr}</div>
                `;
                combinePreviewEl.style.cssText = `
                    position:fixed;
                    left:${rect.right + 10}px;
                    top:${rect.top}px;
                    background:#2b2520;
                    border:2px solid #ffd700;
                    border-radius:8px;
                    padding:10px;
                    z-index:3000;
                    pointer-events:none;
                    min-width:180px;
                `;
            }
            function hideCombinePreview() {
                if (combinePreviewEl) {
                    combinePreviewEl.remove();
                    combinePreviewEl = null;
                }
            }
            const game = new Game();
            function showToast(msg) {
                const container = document.getElementById('game-toast');
                if (!container) return;

                // Ensure container styling for stacking
                container.style.cssText = 'position:fixed;bottom:80px;right:20px;display:flex;flex-direction:column;gap:5px;align-items:flex-end;pointer-events:none;z-index:9000;';

                const t = document.createElement('div');
                t.textContent = msg;
                t.style.cssText = 'background:#2b2520;color:#f0e6d2;padding:8px 12px;border-radius:4px;border-left:4px solid #c5a059;font-size:0.8rem;box-shadow:0 2px 5px rgba(0,0,0,0.5);opacity:0;transform:translateX(20px);transition:all 0.3s ease;font-family:\'Times New Roman\', serif;border:1px solid #4a4036;';

                container.appendChild(t);

                // Animate in
                requestAnimationFrame(() => {
                    t.style.opacity = '1';
                    t.style.transform = 'translateX(0)';
                });

                // Remove after delay
                setTimeout(() => {
                    t.style.opacity = '0';
                    t.style.transform = 'translateX(20px)';
                    setTimeout(() => t.remove(), 300);
                }, 3000);
            }

            function showCombatResult(title, subtitle, color) {
                // Remove any existing result overlay
                document.querySelectorAll('.combat-result-overlay').forEach(e => e.remove());

                const overlay = document.createElement('div');
                overlay.className = 'combat-result-overlay';
                overlay.style.cssText = `
                    position: fixed;
                    top: 0; left: 0; right: 0; bottom: 0;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    background: rgba(0,0,0,0.6);
                    z-index: 9999;
                    animation: fadeIn 0.3s ease;
                    pointer-events: none;
                `;

                const titleEl = document.createElement('div');
                titleEl.style.cssText = `
                    font-size: 4rem;
                    font-weight: bold;
                    color: ${color};
                    text-shadow: 0 0 20px ${color}, 0 0 40px ${color};
                    animation: pulse 0.5s ease;
                `;
                titleEl.textContent = title;

                const subEl = document.createElement('div');
                subEl.style.cssText = `
                    font-size: 1.5rem;
                    color: #ccc;
                    margin-top: 10px;
                `;
                subEl.textContent = subtitle;

                overlay.appendChild(titleEl);
                overlay.appendChild(subEl);
                document.body.appendChild(overlay);

                setTimeout(() => {
                    overlay.style.opacity = '0';
                    overlay.style.transition = 'opacity 0.5s';
                    setTimeout(() => overlay.remove(), 500);
                }, 1500);
            }
            function showDamage(u, a, type = 'ad') {
                const el = document.querySelector(`.unit[data-id="${u.id}"]`);
                if (!el) return;
                const rect = el.getBoundingClientRect();
                const p = document.createElement('div');
                p.className = `hit-damage ${type}`;
                // Position fixed at the unit's center with randomization to prevent overlap
                const offsetX = Math.random() * 40 - 20;
                const offsetY = Math.random() * 40 - 20;
                p.style.left = (rect.left + rect.width / 2 + offsetX) + 'px';
                p.style.top = (rect.top - 10 + offsetY) + 'px';

                // Dynamic font size based on damage
                // Min 1.2rem, Max 3.0rem for big crits
                const size = Math.min(3.0, 1.2 + (a / 500));
                p.style.fontSize = `${size}rem`;
                // Ensure high z-index and bring to front
                p.style.zIndex = Math.floor(6000 + a);

                const prefix = type === 'heal' ? '+' : '';
                p.textContent = `${prefix}${Math.floor(a)}`;
                // Shield damage is gray
                if (type === 'shield') {
                    p.style.color = '#888';
                }
                document.body.appendChild(p);
                setTimeout(() => p.remove(), 1800);
            }
            function createUnitEl(u) {
                const d = document.createElement('div');
                d.className = `unit tier-${u.tier} ${u.owner}`;
                d.dataset.id = u.id;

                // Visual Render (Icon + Name)
                const unitDef = UNIT_DATA[u.name] || {};
                const icon = document.createElement('i');
                icon.className = unitDef.icon || 'ra ra-sword';
                icon.classList.add('unit-bg-icon');
                d.appendChild(icon);

                const nameEl = document.createElement('div');
                nameEl.className = 'u-name';
                nameEl.textContent = unitDef.displayName || u.name;
                d.appendChild(nameEl);

                // Add Hover Event for Unit Detail Box
                d.onmouseenter = (e) => {
                    if (typeof showUnitDetail === 'function') showUnitDetail(u);
                    // Show items on top when hovering
                    const itemBar = d.querySelector('.item-bar');
                    const starIndicator = d.querySelector('.star-indicator');
                    if (itemBar) itemBar.style.zIndex = '130';
                    if (starIndicator) starIndicator.style.zIndex = '100';
                };
                d.onmouseleave = () => {
                    if (typeof hideUnitDetail === 'function') hideUnitDetail();
                    // Show stars on top when not hovering
                    const itemBar = d.querySelector('.item-bar');
                    const starIndicator = d.querySelector('.star-indicator');
                    if (itemBar) itemBar.style.zIndex = '110';
                    if (starIndicator) starIndicator.style.zIndex = '120';
                };

                if (u.owner === 'bot') d.style.color = '#ffb3b3';
                d.draggable = u.owner === 'player';
                // HP and Shield bars (Shield on TOP of HP)
                const hb = document.createElement('div'); hb.className = 'hp-bar-container';

                // HP bar (background layer)
                const hf = document.createElement('div'); hf.className = 'hp-bar-fill';
                const hpPercent = Math.min(100, (u.currentHp / u.maxHp * 100));
                hf.style.width = hpPercent + '%';
                hf.style.zIndex = '1';
                hb.appendChild(hf);

                // Shield bar (front layer - full width, opacity shows remaining)
                const shieldVal = u.shield || 0;
                const maxShield = u.maxShield || shieldVal || u.maxHp;
                if (shieldVal > 0) {
                    const sf = document.createElement('div'); sf.className = 'shield-bar-fill';
                    // Shield covers the HP bar, decreasing from right
                    const shieldPercent = Math.min(100, (shieldVal / maxShield * 100));
                    sf.style.width = shieldPercent + '%';
                    sf.style.transition = 'width 0.3s ease-out'; // Animation for shield reduction
                    sf.style.left = '0';
                    sf.style.zIndex = '2'; // On top of HP
                    hb.appendChild(sf);
                }

                d.appendChild(hb);

                // Star indicator
                let starEl = null;
                if (u.starLevel > 1) {
                    starEl = document.createElement('div'); starEl.className = 'star-indicator';
                    starEl.textContent = ''.repeat(u.starLevel);
                    starEl.style.cssText = 'position:absolute;top:-8px;right:-4px;color:gold;text-shadow:0 0 3px #000;font-size:0.7rem;pointer-events:none;z-index:120;';
                    d.appendChild(starEl);
                }

                const mb = document.createElement('div'); mb.className = 'mana-bar-container';
                const mf = document.createElement('div'); mf.className = 'mana-bar-fill';
                mf.style.width = (u.mana / u.maxMana * 100) + '%';
                mb.appendChild(mf); d.appendChild(mb);

                // Item Display
                u.items = u.items || [];
                if (u.items && u.items.length > 0) {
                    const ib = document.createElement('div');
                    ib.className = 'item-bar';
                    ib.style.cssText = 'position:absolute;top:-8px;left:50%;transform:translateX(-50%);display:flex;gap:2px;z-index:110;pointer-events:none;';

                    // Display regular items
                    u.items.forEach((item, idx) => {
                        const icon = document.createElement('div');
                        let displayIcon = '?';
                        let borderColor = '#aaa';
                        if (typeof item === 'number') { displayIcon = (BASE_ITEMS[item] ? BASE_ITEMS[item].icon : item); borderColor = '#aaa'; }
                        else if (typeof item === 'string') {
                            displayIcon = ITEM_RECIPES[item]?.icon || '';
                            borderColor = '#ffd700';
                        }
                        else if (item.name) { displayIcon = item.name[0]; borderColor = '#ffc'; }

                        icon.style.cssText = `width:16px;height:16px;background:rgba(0,0,0,0.8);border:1px solid ${borderColor};border-radius:2px;cursor:pointer;pointer-events:auto;color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;`;

                        if (displayIcon.startsWith('ra ')) {
                            icon.innerHTML = `<i class="${displayIcon}"></i>`;
                        } else {
                            icon.textContent = displayIcon;
                        }

                        icon.onmouseenter = (e) => {
                            if (typeof showItemTooltip === 'function') showItemTooltip(item, icon.getBoundingClientRect());
                        };
                        icon.onmouseleave = () => {
                            if (typeof hideItemTooltip === 'function') hideItemTooltip();
                        };

                        if (u.owner === 'player') {
                            icon.onclick = (e) => { e.stopPropagation(); game.unequipItem(u, idx); if (typeof hideItemTooltip === 'function') hideItemTooltip(); };
                        }
                        ib.appendChild(icon);
                    });

                    // Display Thief's Gloves bonus items
                    if (u.thiefItems && u.thiefItems.length > 0) {
                        u.thiefItems.forEach(itemId => {
                            const icon = document.createElement('div');
                            const recipe = ITEM_RECIPES[itemId];
                            const displayIcon = recipe?.icon || '';
                            icon.style.cssText = `width:16px;height:16px;background:rgba(0,0,0,0.8);border:1px solid #bb9af7;border-radius:2px;pointer-events:auto;color:#fff;font-size:12px;display:flex;align-items:center;justify-content:center;opacity:0.8;`;
                            if (displayIcon.startsWith('ra ')) {
                                icon.innerHTML = `<i class="${displayIcon}"></i>`;
                            } else {
                                icon.textContent = displayIcon;
                            }
                            icon.title = `() ${recipe?.name || itemId}`;
                            icon.onmouseenter = (e) => {
                                if (typeof showItemTooltip === 'function') showItemTooltip(itemId, icon.getBoundingClientRect());
                            };
                            icon.onmouseleave = () => {
                                if (typeof hideItemTooltip === 'function') hideItemTooltip();
                            };
                            ib.appendChild(icon);
                        });
                    }

                    d.appendChild(ib);
                }

                // Status Effect Icons (combined in one row to avoid overlap)
                const statusEffects = [];
                if (u.isStunned) statusEffects.push({ icon: '', text: '', cls: 'stunned' });
                if (u.isFrozen) statusEffects.push({ icon: '', text: '', cls: 'frozen' });
                if (u.isBurning) statusEffects.push({ icon: '', text: '', cls: 'burning' });

                if (statusEffects.length > 0) {
                    const statusContainer = document.createElement('div');
                    statusContainer.style.cssText = 'position:absolute;top:-18px;left:50%;transform:translateX(-50%);display:flex;gap:2px;z-index:200;pointer-events:none;';
                    statusEffects.forEach(s => {
                        const badge = document.createElement('div');
                        badge.style.cssText = 'background:rgba(0,0,0,0.5);border-radius:3px;padding:2px 4px;font-size:0.6rem;display:flex;align-items:center;gap:1px;';
                        badge.innerHTML = `<span>${s.icon}</span>`;
                        badge.title = s.text;
                        statusContainer.appendChild(badge);
                    });
                    d.appendChild(statusContainer);
                }

                const tt = document.createElement('div'); tt.className = 'unit-tooltip';
                const sp = u.cost * u.starLevel;
                const jpTraitsRaw = u.traits.map(t => SYNERGY_DATA[t] ? SYNERGY_DATA[t].name : t);
                const jpTraits = jpTraitsRaw.join('<br>') + (jpTraitsRaw.length === 2 ? '<br>&nbsp;' : '');
                const posAdvice = (u.type === 'tank' || u.type === 'fighter') ? '' : '';
                const posColor = (u.type === 'tank' || u.type === 'fighter') ? '#ff9e64' : '#7aa2f7';

                // Stats Helper with Breadown
                const fmtStat = (key) => {
                    const d = u.getStatDetails(key);
                    let parts = [];
                    if (d.item > 0) parts.push(`Item:+${d.item}`);
                    if (d.augment > 0) parts.push(`Aug:+${d.augment}`);
                    if (d.synergy > 0) parts.push(`Syn:+${d.synergy}`);

                    const valStr = `<span class="tt-value">${d.total}</span>`;
                    if (parts.length > 0) {
                        return `${valStr} <span style="font-size:0.6rem;color:#aaa;">(${d.base} + ${parts.join(', ')})</span>`;
                    }
                    return valStr;
                };

                // For range, base isn't in u.stats usually unless copied
                const rangeVal = u.getStat('range') || UNIT_DATA[u.name].stats.range || 1;
                const isAP = u.type === 'mage' || u.type === 'enchanter';
                const dmgType = isAP ? 'AP' : 'AD';
                const dmgColor = isAP ? '#0066cc' : '#ff9e64';

                tt.innerHTML = `<div class="tt-name">${UNIT_DATA[u.name].displayName} ${u.starLevel} <span style="color:${dmgColor};font-size:0.7rem;">(${dmgType})</span></div>
            <div class="tt-row"><span class="tt-label">HP</span><span class="tt-value">${u.currentHp} / ${u.maxHp}</span></div>
            <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${Math.floor(u.mana)} / ${u.maxMana}</span></div>
            <div class="tt-row"><span class="tt-label" style="color:${dmgColor}">${isAP ? '(AP)' : '(AD)'}</span>${isAP ? fmtStat('ap') : fmtStat('ad')}</div>
            <div class="tt-row"><span class="tt-label">${isAP ? '(AD)' : '(AP)'}</span>${isAP ? fmtStat('ad') : `<span class="tt-value">0</span>`}</div>
            <div class="tt-row"><span class="tt-label">(AR)</span>${fmtStat('armor')}</div>
            <div class="tt-row"><span class="tt-label">(MR)</span>${fmtStat('mr')}</div>
            <div class="tt-row"><span class="tt-label"></span>${fmtStat('crit')}%</div>
            <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${rangeVal}</span></div>
            <div class="tt-row"><span class="tt-label"></span><span class="tt-value" style="color:${posColor}">${posAdvice}</span></div>
            <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${u.skill.name}</span></div>
            <div style="font-size:0.65rem; color:#aaa; margin-top:4px;">${u.skill.desc}</div>
            <div class="tt-traits">${jpTraits}</div>
            ${u.owner === 'player' && u.isBench ? `<div class="tt-sell">: ${sp}G</div>` : ''}`;
                d.appendChild(tt);

                // Side Detail Panel Hover Logic
                d.onmouseenter = () => {
                    if (u.isBench) return;
                    const box = document.getElementById('unit-detail-box');
                    // Ensure visible and positioned correctly if not set by updateUI yet
                    box.style.display = 'block';
                    // Content update
                    const ownerTxt = u.owner === 'player' ? '' : '';
                    const ownerCol = u.owner === 'player' ? '#6b8c73' : '#a65e5e';
                    box.innerHTML = `
                    <div style="font-weight:bold; color:${ownerCol}; border-bottom:1px solid ${ownerCol}40; margin-bottom:8px; padding-bottom:4px;">
                        : ${ownerTxt}
                    </div>
                ` + tt.innerHTML;
                    box.style.borderColor = ownerCol;
                };
                d.onmouseleave = () => {
                    document.getElementById('unit-detail-box').style.display = 'none';
                };

                if (u.owner === 'player') {
                    d.onclick = e => { e.stopPropagation(); game.selectedUnit = game.selectedUnit === u ? null : u; updateUI(); };
                    d.ondragstart = () => { game.dragged = u; game.draggedItem = null; if (typeof showSellZone === 'function') showSellZone('unit'); };
                    d.ondragend = () => { game.dragged = null; if (typeof hideSellZone === 'function') hideSellZone(); };
                }
                if (game.selectedUnit === u) d.classList.add('selected');
                return d;
            }

            function updateUI() {
                const sm = Math.floor((game.stage - 1) / 5) + 1;
                const sn = ((game.stage - 1) % 5) + 1;
                document.getElementById('stage-display').textContent = `Stage ${sm}-${sn}`;

                const streakBonus = game.getStreakBonus(game.streak);
                const totalNext = 5 + game.interest + streakBonus;
                document.getElementById('player-gold').innerHTML = `Gold: ${game.gold} <span style="font-size:0.75rem; color:#aaa;">(+${totalNext} : 5 ${game.interest} ${game.streak > 0 ? '' : ''}${streakBonus})</span>`;

                document.getElementById('player-health').textContent = `You: ${game.hp}`;
                document.getElementById('opponent-health').textContent = `Bot: ${game.botHp}`;
                document.getElementById('bot-info').textContent = `Lv${game.botLevel} | ${game.botGold}G`;
                document.getElementById('level-info').textContent = `Lv${game.level} (${game.xp}/${XP_TABLE[game.level] || 'MAX'})`;

                // Streak UI
                const renderStreak = (id, s) => {
                    const el = document.getElementById(id);
                    if (s === 0) { el.innerHTML = ''; return; }
                    const isWin = s > 0;
                    const abs = Math.abs(s);
                    const icon = isWin ? '' : '';
                    const cls = isWin ? 'streak-fire' : 'streak-ice';
                    el.innerHTML = `<span class="${cls}">${icon} ${abs} ${isWin ? '' : ''}</span>`;
                };
                renderStreak('player-streak', game.streak);
                renderStreak('bot-streak', game.botStreak);

                // Refresh Button Update
                const refBtn = document.getElementById('btn-refresh');
                if (refBtn) {
                    if (game.freeRerolls > 0) {
                        refBtn.innerHTML = ' <span style="font-size:0.8rem;color:inherit;">()</span>';
                        refBtn.style.borderColor = '#7dcfff';
                        refBtn.style.opacity = '1';
                    } else {
                        refBtn.innerHTML = ' <span style="font-size:0.8rem;color:inherit;">(2G)</span>';
                        refBtn.style.borderColor = '#444';
                        if (game.gold < 2) refBtn.style.opacity = '0.5'; else refBtn.style.opacity = '1';
                    }
                }

                // Augment Overlay Management
                const augOverlay = document.getElementById('augment-overlay');
                if (game.isChoosingAugment) {
                    augOverlay.style.display = 'flex';
                    const list = document.getElementById('augment-list');
                    list.innerHTML = '';
                    game.augmentChoices.forEach((aug, idx) => {
                        const card = document.createElement('div');
                        card.className = `augment-card ${aug.tier}`;

                        // Tier color
                        const tierColor = aug.tier === 'prismatic' ? '#bb9af7' : aug.tier === 'gold' ? '#ffd700' : '#c0c0c0';
                        const tierName = aug.tier === 'prismatic' ? '' : aug.tier === 'gold' ? '' : '';

                        // Effect icon (RPG Awesome)
                        let effectIconClass = 'ra ra-scroll-unfurled';
                        if (aug.effect.includes('hp') || aug.effect.includes('health')) effectIconClass = 'ra ra-health';
                        else if (aug.effect.includes('ad') || aug.effect.includes('attack')) effectIconClass = 'ra ra-sword';
                        else if (aug.effect.includes('ap') || aug.effect.includes('magic')) effectIconClass = 'ra ra-crystal-ball';
                        else if (aug.effect.includes('as') || aug.effect.includes('speed')) effectIconClass = 'ra ra-lightning-bolt';
                        else if (aug.effect.includes('armor') || aug.effect.includes('reduce') || aug.effect.includes('shield')) effectIconClass = 'ra ra-shield';
                        else if (aug.effect.includes('mr')) effectIconClass = 'ra ra-helmet';
                        else if (aug.effect.includes('gold') || aug.effect.includes('eco') || aug.effect.includes('rich')) effectIconClass = 'ra ra-gold-bar';
                        else if (aug.effect.includes('xp') || aug.effect.includes('level')) effectIconClass = 'ra ra-level-up';
                        else if (aug.effect.includes('summon') || aug.effect.includes('clone')) effectIconClass = 'ra ra-player';
                        else if (aug.effect.includes('item') || aug.effect.includes('thief') || aug.effect.includes('binary') || aug.effect.includes('component')) effectIconClass = 'ra ra-gem';
                        else if (aug.effect.includes('heal') || aug.effect.includes('regen') || aug.effect.includes('vamp')) effectIconClass = 'ra ra-heart';
                        else if (aug.effect.includes('trait') || aug.effect.includes('soul') || aug.effect.includes('heart')) effectIconClass = 'ra ra-book';
                        else if (aug.effect.includes('range') || aug.effect.includes('scope')) effectIconClass = 'ra ra-telescope';
                        else if (aug.effect.includes('roll')) effectIconClass = 'ra ra-cycle';
                        else if (aug.effect.includes('bench')) effectIconClass = 'ra ra-wooden-sign';
                        else if (aug.effect.includes('pandora')) effectIconClass = 'ra ra-question';
                        else if (aug.effect.includes('ascend') || aug.effect.includes('sun')) effectIconClass = 'ra ra-sun';

                        const hasReroll = game.augmentRerolls && game.augmentRerolls[idx] > 0;
                        const rerollCount = game.augmentRerolls ? game.augmentRerolls[idx] : 0;

                        card.innerHTML = `
                        <div style="font-size:3rem;margin-bottom:10px;"><i class="${effectIconClass}"></i></div>
                        <div style="font-size:0.7rem;color:${tierColor};text-transform:uppercase;letter-spacing:1px;margin-bottom:5px;">${tierName}</div>
                        <div class="augment-name">${aug.name}</div>
                        <div class="augment-desc">${aug.desc}</div>
                    `;

                        card.onclick = () => game.chooseAugment(idx);

                        // Container for card + reroll button
                        const container = document.createElement('div');
                        container.style.cssText = 'display:flex;flex-direction:column;align-items:center;gap:8px;';
                        container.appendChild(card);

                        // Reroll button below card
                        const rerollBtn = document.createElement('button');
                        rerollBtn.className = 'aug-reroll-btn';
                        rerollBtn.style.cssText = `padding:6px 12px;background:${hasReroll ? 'rgba(197,160,89,0.2)' : 'rgba(50,50,50,0.5)'};border:1px solid ${hasReroll ? '#c5a059' : '#444'};border-radius:5px;color:${hasReroll ? '#c5a059' : '#666'};cursor:${hasReroll ? 'pointer' : 'not-allowed'};font-size:0.7rem;display:flex;align-items:center;gap:4px;`;

                        rerollBtn.innerHTML = `<i class="ra ra-cycle"></i>  (${rerollCount})`;
                        rerollBtn.disabled = !hasReroll;
                        rerollBtn.onclick = (e) => { e.stopPropagation(); game.rerollAugment(idx); };
                        container.appendChild(rerollBtn);

                        list.appendChild(container);
                    });
                } else {
                    augOverlay.style.display = 'none';
                }

                // Render Acquired Augments
                const augListContainer = document.getElementById('augment-list-container');
                if (augListContainer) {
                    // Remove header logic if it exists
                    let header = document.getElementById('augment-list-header');
                    if (header) header.remove();

                    augListContainer.innerHTML = ''; // Clear container
                    augListContainer.style.cssText = 'display:flex;gap:10px;background:rgba(0,0,0,0);padding:0;border:none;';

                    // Helper to render lists
                    const renderList = (title, list, isBot) => {
                        const section = document.createElement('div');
                        section.style.flex = '1'; // Flex column
                        // Header inside section removed? Or just main header?
                        // User said "augment title text -> delete". "YOU/BOT title -> above".
                        // Wait, previous request was "Title YOU/BOT above". Now "Delete augment char".
                        // I will keep YOU/BOT labels for clarity but remove "Augment" big header.

                        const label = document.createElement('div');
                        label.textContent = title;
                        label.style.fontSize = '0.65rem';
                        label.style.color = isBot ? '#f7768e' : '#7aa2f7';
                        label.style.borderBottom = isBot ? '1px solid #f7768e' : '1px solid #7aa2f7';
                        label.style.marginBottom = '4px';
                        section.appendChild(label);

                        if (list.length === 0) {
                            const empty = document.createElement('span');
                            empty.textContent = '()';
                            empty.style.color = '#555';
                            empty.style.fontSize = '0.65rem';
                            section.appendChild(empty);
                        } else {
                            list.forEach(aug => {
                                const el = document.createElement('div');
                                el.style.cssText = 'width:100%;padding:4px 6px;margin-bottom:4px;border-radius:4px;background:rgba(255,255,255,0.05);border:1px solid #444;display:flex;align-items:center;gap:6px;';
                                if (isBot) el.style.borderColor = '#f7768e';

                                // Tier Color
                                const tColor = aug.tier === 'prismatic' ? '#bb9af7' : aug.tier === 'gold' ? '#ffd700' : '#c0c0c0';

                                // Simple Icon
                                const tierIcon = document.createElement('div');
                                tierIcon.style.cssText = `font-size:1.2rem;line-height:1;margin-right:4px;display:flex;align-items:center;`;
                                let iconClass = 'ra ra-sparkles';
                                if (aug.effect.includes('hp')) iconClass = 'ra ra-health';
                                else if (aug.effect.includes('ad')) iconClass = 'ra ra-sword';
                                else if (aug.effect.includes('ap')) iconClass = 'ra ra-crystal-ball';
                                else if (aug.effect.includes('gold') || aug.effect.includes('eco')) iconClass = 'ra ra-gold-bar';
                                else if (aug.effect.includes('xp') || aug.effect.includes('level')) iconClass = 'ra ra-level-up';
                                tierIcon.innerHTML = `<i class="${iconClass}"></i>`;
                                el.appendChild(tierIcon);

                                // Text Container
                                const txt = document.createElement('div');
                                txt.style.cssText = 'flex:1;display:flex;flex-direction:column;overflow:hidden;';
                                txt.innerHTML = `
                                <div style="font-size:0.7rem;font-weight:bold;color:${tColor};white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${aug.name}</div>
                                <div style="font-size:0.6rem;color:#888;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${aug.desc}</div>
                            `;
                                el.appendChild(txt);

                                el.title = `${aug.name}\n[${aug.tier.toUpperCase()}]\n${aug.desc}`;
                                section.appendChild(el);
                            });
                        }
                        augListContainer.appendChild(section);
                    };

                    renderList('YOU', game.augments, false);
                    renderList('BOT', game.botAugments || [], true);
                }

                // Adjust Guide Panel Layout
                const gp = document.getElementById('item-guide-panel');
                if (gp) {
                    const closeBtn = gp.querySelector('.guide-close-btn');
                    if (closeBtn) closeBtn.style.display = 'none';
                    // Align lines: Top of guide = Top of Unit details = Top of Synergy
                    // Adjust margin/top logic if necessary. Assuming parent is relative or fixed.
                    // If fixed, top style works.
                    gp.style.top = '120px';
                }
                const syn = document.getElementById('synergy-list-container');
                if (syn) syn.style.top = '120px';
                // Remove redundant unit detail box absolute positioning here, handled by showUnitDetail
                // Augment List Container
                const alc = document.getElementById('augment-list-container');
                if (alc) {
                    alc.style.display = 'flex';
                    alc.style.gap = '10px';
                    alc.style.background = 'transparent';
                    // Ensure columns
                    Array.from(alc.children).forEach(c => c.style.flex = '1');
                }

                // Inventory Rendering
                // Inventory Rendering
                document.querySelectorAll('.item-tooltip').forEach(e => e.remove()); // Cleanup ghosts
                const inv = document.getElementById('inventory-container');
                inv.innerHTML = '';
                // Style already in CSS, but ensure grid settings match
                inv.style.display = 'grid';
                inv.style.gridTemplateColumns = 'repeat(8, 40px)';
                inv.style.gridTemplateRows = 'repeat(2, 40px)';
                inv.style.gap = '4px';
                inv.style.padding = '8px';
                inv.style.justifyContent = 'center';
                for (let i = 0; i < game.inventory.length; i++) {
                    const item = game.inventory[i];
                    const s = document.createElement('div');
                    s.className = 'inventory-slot';
                    s.style.width = '42px'; s.style.height = '42px'; s.style.position = 'relative'; s.style.border = '1px solid #444';
                    s.ondragover = e => {
                        e.preventDefault();
                        // Show combine preview if dragging component over different component slot
                        if (game.draggedItem && game.draggedItem.index !== i && game.inventory[i] && typeof game.draggedItem.item === 'number' && typeof game.inventory[i] === 'number') {
                            const item1 = game.draggedItem.item;
                            const item2 = game.inventory[i];
                            const recipeKey = item1 <= item2 ? `${item1}-${item2}` : `${item2}-${item1}`;
                            const recipe = ITEM_RECIPES[recipeKey];
                            if (recipe && typeof showCombinePreview === 'function') {
                                showCombinePreview(recipe, s.getBoundingClientRect());
                            }
                        }
                    };
                    s.ondragleave = e => {
                        if (typeof hideCombinePreview === 'function') hideCombinePreview();
                    };
                    s.ondrop = (e) => {
                        e.preventDefault();
                        if (typeof hideCombinePreview === 'function') hideCombinePreview();
                        if (game.draggedItem && game.draggedItem.index !== i) {
                            // If dropping onto another item -> Combine
                            if (game.inventory[i]) {
                                game.combineItems(game.draggedItem.index, i);
                            } else {
                                // Move item to empty slot
                                game.inventory[i] = game.inventory[game.draggedItem.index];
                                game.inventory[game.draggedItem.index] = null;
                                updateUI();
                            }
                            game.draggedItem = null;
                        }
                    };

                    if (item) {
                        const icon = document.createElement('div');
                        icon.className = 'item-icon';
                        let itemName = '';
                        let displayIcon = '?';
                        let isCompleted = false;

                        if (typeof item === 'number') {
                            itemName = BASE_ITEMS[item] ? BASE_ITEMS[item].name : '???';
                            const iconClass = BASE_ITEMS[item] ? BASE_ITEMS[item].icon : '';
                            displayIcon = iconClass ? `<i class="${iconClass}"></i>` : '?';
                        }
                        else if (typeof item === 'string' && ITEM_RECIPES[item]) {
                            itemName = ITEM_RECIPES[item].name;
                            if (ITEM_RECIPES[item].icon) {
                                displayIcon = `<i class="${ITEM_RECIPES[item].icon}"></i>`;
                            } else {
                                const parts = item.split('-').map(Number);
                                const i1 = (BASE_ITEMS[parts[0]] ? `<i class="${BASE_ITEMS[parts[0]].icon}"></i>` : '?');
                                const i2 = (BASE_ITEMS[parts[1]] ? `<i class="${BASE_ITEMS[parts[1]].icon}"></i>` : '?');
                                displayIcon = `<div style="display:flex;scale:0.8;">${i1}${i2}</div>`;
                            }
                            isCompleted = true;
                        }
                        else { itemName = item.name || '???'; displayIcon = '?'; }

                        if (!isCompleted) icon.style.borderColor = '#aaa';
                        else icon.style.borderColor = '#ffd700';

                        icon.style.width = '100%'; icon.style.height = '100%';
                        icon.style.display = 'flex'; icon.style.alignItems = 'center'; icon.style.justifyContent = 'center';
                        icon.style.fontSize = isCompleted ? '16px' : '20px';
                        icon.innerHTML = displayIcon;

                        // Draggable
                        icon.draggable = true;
                        icon.ondragstart = (e) => {
                            game.draggedItem = { index: i, item: item };
                            if (typeof showSellZone === 'function') showSellZone('item');
                        };
                        icon.ondragend = () => { if (typeof hideSellZone === 'function') hideSellZone(); };

                        // Custom Tooltip
                        icon.onmouseenter = (e) => {
                            if (typeof showItemTooltip === 'function') showItemTooltip(item, icon.getBoundingClientRect());
                        };
                        icon.onmouseleave = () => {
                            if (typeof hideItemTooltip === 'function') hideItemTooltip();
                        };

                        icon.draggable = true;
                        icon.ondragstart = (e) => {
                            game.draggedItem = { index: i, item: item };
                            game.dragged = null; // Clear unit drag
                            e.dataTransfer.setData('text/plain', i);
                        };
                        s.appendChild(icon);
                    }
                    inv.appendChild(s);
                }

                // Drop Table Update
                const dtC = document.getElementById('drop-table-container');
                const colors = ['#fff', '#9ece6a', '#7aa2f7', '#bb9af7', '#e0af68'];
                let header = '<div style="font-weight:bold;margin-bottom:5px;border-bottom:1px solid #444;display:flex;">';
                header += '<span style="width:30px;">Lv</span>';
                for (let i = 0; i < 5; i++) header += `<span style="color:${colors[i]};flex:1;text-align:right;">T${i + 1}</span>`;
                header += '</div>';
                dtC.innerHTML = header;

                const levels = []; for (let i = 1; i <= 11; i++) levels.push(i);
                levels.forEach(lv => {
                    const row = document.createElement('div');
                    row.className = 'drop-row' + (lv === game.level ? ' current-lv' : '');
                    let content = `<span style="width:30px;">${lv}</span>`;
                    const rates = DROP_RATES[lv] || DROP_RATES[9];
                    rates.forEach((r, i) => {
                        content += `<span style="color:${colors[i]};flex:1;text-align:right;opacity:${r > 0 ? 1 : 0.2}">${r}%</span>`;
                    });
                    row.innerHTML = content;
                    dtC.appendChild(row);
                });

                const bEl = document.getElementById('player-bench'); bEl.innerHTML = '';
                for (let i = 0; i < 9; i++) {
                    const s = document.createElement('div'); s.className = 'slot';
                    s.ondragover = e => e.preventDefault();
                    s.ondrop = () => { if (game.dragged) game.move(game.dragged, { type: 'bench', idx: i }); };
                    s.onclick = () => { if (game.selectedUnit) game.move(game.selectedUnit, { type: 'bench', idx: i }); };
                    if (game.bench[i]) s.appendChild(createUnitEl(game.bench[i]));
                    bEl.appendChild(s);
                }

                const pb = document.getElementById('player-board'); pb.innerHTML = '';
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 7; c++) {
                        const cl = document.createElement('div'); cl.className = 'hex-cell';
                        cl.ondragover = e => e.preventDefault();
                        cl.ondrop = (e) => {
                            e.preventDefault();
                            if (game.dragged) {
                                game.move(game.dragged, { type: 'board', r, c });
                                game.dragged = null;
                            } else if (game.draggedItem) {
                                // Check if there is a unit here
                                const unit = game.board[r][c];
                                if (unit) {
                                    game.equipItem(unit, game.draggedItem.index);
                                }
                                game.draggedItem = null;
                            }
                        };
                        cl.onclick = () => { if (game.selectedUnit) game.move(game.selectedUnit, { type: 'board', r, c }); };
                        if (c === 0) {
                            const l = document.createElement('div'); l.className = 'row-label';
                            l.textContent = r < 2 ? '' : ''; cl.appendChild(l);
                        }
                        if (game.board[r][c]) cl.appendChild(createUnitEl(game.board[r][c]));
                        pb.appendChild(cl);
                    }
                }

                const ob = document.getElementById('opponent-board'); ob.innerHTML = '';
                for (let r = 0; r < 4; r++) {
                    for (let c = 0; c < 7; c++) {
                        const cl = document.createElement('div'); cl.className = 'hex-cell';
                        // Check if a player unit has moved into this cell of the bot's board
                        const unit = game.botBoard[r][c];
                        if (unit) cl.appendChild(createUnitEl(unit));
                        ob.appendChild(cl);
                    }
                }

                const sEl = document.getElementById('shop'); sEl.innerHTML = '';
                game.shopCards.forEach((n, i) => {
                    if (!n) { const e = document.createElement('div'); e.style.width = '120px'; sEl.appendChild(e); return; }
                    const d = UNIT_DATA[n];
                    const star = game.shopStars[i] || 1;
                    const cost = d.cost * Math.pow(3, star - 1);

                    const cd = document.createElement('div');
                    cd.className = `shop-card tier-${d.tier} ${star > 1 ? 'star-2' : ''}`;

                    const shopJpTraitsRaw = d.traits.map(t => SYNERGY_DATA[t] ? SYNERGY_DATA[t].name : t);
                    const shopJpTraitsHtml = shopJpTraitsRaw.join('<br>') + (shopJpTraitsRaw.length === 2 ? '<br>&nbsp;' : '');
                    const starColor = star > 1 ? '#ffd700' : '#ccc';
                    const starShadow = star > 1 ? '0 0 5px gold' : 'none';
                    const starStr = `<div style="color:${starColor};font-weight:bold;text-align:center;text-shadow:${starShadow};position:relative;z-index:2;">${star}</div>`;

                    const crit = d.stats.crit || 10;

                    // Watermark Icon
                    let watermark = '';
                    if (d.icon && d.icon.startsWith('ra ')) {
                        watermark = `<i class="${d.icon}" style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:60px;opacity:0.15;z-index:0;color:#fff;pointer-events:none;"></i>`;
                    }

                    const posAdvice = (d.type === 'tank' || d.type === 'fighter') ? '' : '';
                    const posColor = (d.type === 'tank' || d.type === 'fighter') ? '#ff9e64' : '#7aa2f7';

                    cd.innerHTML = `${watermark}<strong style="position:relative;z-index:2;">${d.displayName}</strong>${starStr}<div style="font-size:0.6rem;text-align:center;line-height:1.2;position:relative;z-index:2;">${shopJpTraitsHtml}</div><div style="font-size:0.6rem;color:#aaa;position:relative;z-index:2;">Tier ${d.tier} | <span style="color:${posColor}">${posAdvice}</span></div><span style="color:${star > 1 ? '#ffd700' : 'gold'};position:relative;z-index:2;">${cost}G</span>`;

                    const tt = document.createElement('div'); tt.className = 'unit-tooltip';

                    // Tooltip content (Full detail)
                    const rangeVal = d.stats.range || 1;
                    const manaVal = d.maxMana || 100;
                    const ar = d.stats.armor || 20;
                    const mr = d.stats.mr || 20;
                    const isShopAP = d.type === 'mage' || d.type === 'enchanter';
                    const shopDmgType = isShopAP ? 'AP' : 'AD';
                    const shopDmgColor = isShopAP ? '#0066cc' : '#ff9e64';
                    tt.innerHTML = `<div class="tt-name">${d.displayName} ${star} <span style="color:${shopDmgColor};font-size:0.7rem;">(${shopDmgType})</span></div>
                    <div class="tt-row"><span class="tt-label">HP</span><span class="tt-value">${Math.floor(d.stats.hp * (star === 2 ? 1.8 : 1))}</span></div>
                    <div class="tt-row"><span class="tt-label"></span><span class="tt-value">0 / ${manaVal}</span></div>
                    <div class="tt-row"><span class="tt-label" style="color:${shopDmgColor}">${isShopAP ? '(AP)' : '(AD)'}</span><span class="tt-value" style="color:${shopDmgColor}">${isShopAP ? '100' : Math.floor(d.stats.ad * (star === 2 ? 1.8 : 1))}</span></div>
                    <div class="tt-row"><span class="tt-label">${isShopAP ? '(AD)' : '(AP)'}</span><span class="tt-value">${isShopAP ? Math.floor(d.stats.ad * (star === 2 ? 1.8 : 1)) : '0'}</span></div>
                    <div class="tt-row"><span class="tt-label">(AR)</span><span class="tt-value">${ar}</span></div>
                    <div class="tt-row"><span class="tt-label">(MR)</span><span class="tt-value">${mr}</span></div>
                    <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${crit}%</span></div>
                    <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${rangeVal}</span></div>
                    <div class="tt-row"><span class="tt-label"></span><span class="tt-value" style="color:${d.type === 'tank' || d.type === 'fighter' ? '#ff9e64' : '#7aa2f7'}">${d.type === 'tank' || d.type === 'fighter' ? '' : ''}</span></div>
                    <div class="tt-row"><span class="tt-label"></span><span class="tt-value">${d.skill.name}</span></div>
                    <div style="font-size:0.65rem; color:#aaa; margin-top:4px;">${d.skill.desc}</div>
                    <div class="tt-traits">${d.traits.map(t => SYNERGY_DATA[t] ? SYNERGY_DATA[t].name : t).join('<br>') + (d.traits.length === 2 ? '<br>&nbsp;' : '')}</div>`;
                    cd.appendChild(tt);
                    cd.onclick = () => game.buy(i); sEl.appendChild(cd);
                });

                renderSynergies('synergy-panel', game.playerUnits.filter(u => !u.isBench));
                renderSynergies('bot-synergy-panel', game.botUnits.filter(u => !u.isBench));
                updateSynergyList();
                game.updateItemGuide();
            }

            function updateSynergyList() {
                const container = document.getElementById('synergy-list-content');
                if (!container) return;

                // Active Synergy Count Calculation (Consolidated)
                const pUnits = game.playerUnits.filter(u => !u.isBench);
                const unq = new Map(); pUnits.forEach(u => unq.set(u.name, u));
                const activeCts = {};
                unq.forEach(u => {
                    const traits = new Set(u.traits || []);
                    // Check items for emblems
                    (u.items || []).forEach(it => {
                        let d = null;
                        if (typeof it === 'string' && ITEM_RECIPES[it]) d = ITEM_RECIPES[it];
                        else if (typeof it === 'number' && BASE_ITEMS[it]) d = BASE_ITEMS[it];
                        if (d && d.traits) d.traits.forEach(t => traits.add(t));
                    });
                    // Check temporary items
                    if (u.thiefItems) {
                        u.thiefItems.forEach(itId => {
                            const d = ITEM_RECIPES[itId];
                            if (d && d.traits) d.traits.forEach(t => traits.add(t));
                        });
                    }
                    traits.forEach(t => activeCts[t] = (activeCts[t] || 0) + 1);
                });

                // Augment Trait Bonuses for UI

                // Add Extra Synergies from Augments (Flag-based)
                if (game.extraSynergies) {
                    Object.keys(game.extraSynergies).forEach(k => {
                        const val = game.extraSynergies[k];
                        if (val > 0) activeCts[k] = (activeCts[k] || 0) + val;
                    });
                }

                // Always clear and re-render to ensure all event listeners (including new hover details) are attached
                container.innerHTML = '';

                // Sort synergies: active first (by tier desc), then inactive alphabetically
                const getActiveTier = (sId, count) => {
                    const def = SYNERGY_DATA[sId];
                    for (let l of [...def.levels].sort((a, b) => b.count - a.count)) {
                        if (count >= l.count) {
                            if (l.type.includes('prismatic')) return 4;
                            if (l.type.includes('gold')) return 3;
                            if (l.type.includes('silver')) return 2;
                            return 1; // bronze
                        }
                    }
                    return 0; // inactive
                };

                const sortedSynergyIds = Object.keys(SYNERGY_DATA).sort((a, b) => {
                    const countA = activeCts[a] || 0;
                    const countB = activeCts[b] || 0;

                    const tierA = getActiveTier(a, countA);
                    const tierB = getActiveTier(b, countB);

                    if (tierB !== tierA) return tierB - tierA; // Sort by Active Tier (Level)
                    if (countB !== countA) return countB - countA; // Sort by Count (including inactive ones)
                    return a.localeCompare(b);
                });

                sortedSynergyIds.forEach(sId => {
                    const def = SYNERGY_DATA[sId];
                    const count = activeCts[sId] || 0;
                    const minLevel = def.levels[0]?.count || 1;

                    // Show all synergies (active ones with highlight)
                    let activeType = '';
                    for (let l of [...def.levels].sort((a, b) => b.count - a.count)) { if (count >= l.count) { activeType = l.type; break; } }

                    const card = document.createElement('div');
                    card.className = 'synergy-card';

                    card.innerHTML = `
                            <div class="synergy-card-title" title="${def.name}\n${def.levels.map(l => `(${l.count}) ${l.effect}`).join('\n')}">
                                ${def.name} <span id="list-status-${sId}" class="synergy-status ${activeType}">${count}</span>
                            </div>
                            `;

                    // Add unit chips
                    const unitsByTier = {};
                    Object.keys(UNIT_DATA).forEach(uName => {
                        if (UNIT_DATA[uName].traits.includes(sId)) {
                            const u = UNIT_DATA[uName];
                            if (!unitsByTier[u.tier]) unitsByTier[u.tier] = [];
                            unitsByTier[u.tier].push(uName);
                        }
                    });

                    [1, 2, 3, 4, 5].forEach(t => {
                        if (unitsByTier[t]) {
                            const tierRow = document.createElement('div');
                            tierRow.className = 'synergy-tier-row';
                            let color = '#ccc';
                            if (t === 1) color = '#fff';
                            if (t === 2) color = '#9ece6a';
                            if (t === 3) color = '#7aa2f7';
                            if (t === 4) color = '#bb9af7';
                            if (t === 5) color = '#e0af68';

                            tierRow.innerHTML = `
                            <div class="tier-header" style="color:${color}">Tier ${t}</div>
                            <div class="unit-chips">
                                ${unitsByTier[t].map(name => {
                                const d = UNIT_DATA[name];
                                let dmgType = '';
                                let dmgColor = '#ff9e64';
                                if (d.type === 'mage' || d.type === 'enchanter') { dmgType = ''; dmgColor = '#7dcfff'; }
                                const apVal = 100; // Base AP
                                const crit = d.stats.crit || 10;
                                return `<span class="unit-chip" style="color:${color}; cursor:pointer;" 
                                    onmouseenter="const rect=this.getBoundingClientRect(); if(typeof showUnitDetail==='function') showUnitDetail({name:'${name}', ...UNIT_DATA['${name}'], starLevel:1, owner:'player', getStat: function(s){ return this.stats[s] || (s==='attackSpeed'?1.0:0); }, items:[], maxHp:UNIT_DATA['${name}'].stats.hp, currentHp:UNIT_DATA['${name}'].stats.hp, mana:0, maxMana:UNIT_DATA['${name}'].stats.mana||100}, rect)"
                                    onmouseleave="if(typeof hideUnitDetail==='function') hideUnitDetail()"
                                    title="${d.displayName} (${dmgType})">${d.displayName}</span>`;
                            }).join('')}
                            </div>
                            `;
                            card.appendChild(tierRow);
                        }
                    });

                    container.appendChild(card);
                });
            }

            function renderSynergies(p, units) {
                const el = document.getElementById(p);
                const prevActive = {};
                // Store previous active synergies to detect new activations
                el.querySelectorAll('.synergy-item').forEach(item => {
                    const name = item.textContent.split(' ')[0];
                    prevActive[name] = item.classList.contains('bronze') || item.classList.contains('silver') || item.classList.contains('gold');
                });

                el.innerHTML = `<div style="color:#7aa2f7;font-size:0.8rem;margin-bottom:5px;font-weight:bold;text-align:${p === 'bot-synergy-panel' ? 'right' : 'left'}">${p === 'synergy-panel' ? '' : ''}</div>`;
                const unq = new Map(); units.forEach(u => unq.set(u.name, u));
                const cts = {};
                unq.forEach(u => {
                    const traits = new Set(u.traits || []);
                    // Check items for emblems
                    (u.items || []).forEach(it => {
                        let d = null;
                        if (typeof it === 'string' && ITEM_RECIPES[it]) d = ITEM_RECIPES[it];
                        else if (typeof it === 'number' && BASE_ITEMS[it]) d = BASE_ITEMS[it];
                        if (d && d.traits) d.traits.forEach(t => traits.add(t));
                    });
                    // Check temporary items
                    if (u.thiefItems) {
                        u.thiefItems.forEach(itId => {
                            const d = ITEM_RECIPES[itId];
                            if (d && d.traits) d.traits.forEach(t => traits.add(t));
                        });
                    }
                    traits.forEach(t => cts[t] = (cts[t] || 0) + 1);
                });

                // Add Extra Synergies from Augments (Flag-based)
                const extra = p === 'synergy-panel' ? game.extraSynergies : game.botExtraSynergies;
                if (extra) {
                    Object.keys(extra).forEach(k => {
                        cts[k] = (cts[k] || 0) + extra[k];
                    });
                }

                Object.entries(cts).sort((a, b) => b[1] - a[1]).forEach(([t, count]) => {
                    const def = SYNERGY_DATA[t]; if (!def) return;
                    let ac = ''; for (let l of [...def.levels].sort((a, b) => b.count - a.count)) { if (count >= l.count) { ac = l.type; break; } }
                    const v = document.createElement('div'); v.className = 'synergy-item ' + ac;
                    v.dataset.synergy = t;
                    v.textContent = `${def.name} ${count}`;

                    // Highlight if newly activated
                    const isNowActive = ac !== '';
                    const wasActive = prevActive[def.name] || false;
                    if (isNowActive && !wasActive && game.phase === 'combat') {
                        v.classList.add('highlight');
                        setTimeout(() => v.classList.remove('highlight'), 600);
                    }

                    const tt = document.createElement('div'); tt.className = 'synergy-tooltip';
                    let txt = `${def.name}\n`;
                    def.levels.forEach(l => txt += `${count >= l.count ? '' : ''} (${l.count}) ${l.effect}\n`);
                    tt.textContent = txt;
                    v.appendChild(tt);

                    v.onmouseenter = () => {
                        tt.style.display = 'block';
                        const r = v.getBoundingClientRect();
                        tt.style.top = r.top + 'px';
                        if (p === 'bot-synergy-panel') {
                            tt.style.left = 'auto';
                            tt.style.right = (window.innerWidth - r.left + 5) + 'px';
                        } else {
                            tt.style.left = (r.right + 5) + 'px';
                            tt.style.right = 'auto';
                        }
                    };
                    v.onmouseleave = () => { tt.style.display = 'none'; };

                    el.appendChild(v);
                });
            }

            document.getElementById('btn-start').onclick = () => game.startCombat();
            document.getElementById('btn-refresh').onclick = () => {
                if (game.freeRerolls > 0) {
                    game.freeRerolls--;
                    game.fillShop();
                    updateUI();
                } else if (game.gold >= 2) {
                    game.gold -= 2;
                    game.fillShop();
                    updateUI();
                }
            };
            document.getElementById('btn-buy-xp').onclick = () => game.buyXp();
            document.getElementById('btn-mini-refresh').onclick = () => {
                game.checkAllUpgrades('player');
                updateUI();
            };

            document.getElementById('btn-syn-prev').onclick = () => {
                const container = document.getElementById('synergy-list-content');
                if (container.scrollLeft <= 5) {
                    // Wrap to end
                    container.scrollTo({ left: container.scrollWidth, behavior: 'smooth' });
                } else {
                    container.scrollBy({ left: -170, behavior: 'smooth' });
                }
            };
            document.getElementById('btn-syn-next').onclick = () => {
                const container = document.getElementById('synergy-list-content');
                // If at the end (with a small buffer)
                if (container.scrollLeft + container.clientWidth >= container.scrollWidth - 5) {
                    // Wrap to start
                    container.scrollTo({ left: 0, behavior: 'smooth' });
                } else {
                    container.scrollBy({ left: 170, behavior: 'smooth' });
                }
            };

            const sz = document.getElementById('sell-zone');
            sz.ondragover = e => e.preventDefault();
            sz.ondrop = (e) => {
                e.preventDefault();
                if (game.dragged) {
                    game.sell(game.dragged);
                } else if (game.draggedItem) {
                    game.inventory[game.draggedItem.index] = null;
                    updateUI();
                }
            };
            sz.onclick = () => { if (game.selectedUnit) game.sell(game.selectedUnit); };



            // Global Sell/Trash Zone
            const gsz = document.createElement('div');
            gsz.id = 'global-sell-zone';
            gsz.style.cssText = 'position:fixed;bottom:0;left:0;width:100%;height:120px;background:linear-gradient(to top, rgba(20,20,30,0.95), rgba(20,20,30,0));display:none;justify-content:center;align-items:center;z-index:9000;opacity:0;transition:opacity 0.2s;pointer-events:none;';
            gsz.innerHTML = `
            <div id="sell-drop-target" style="width:100%;height:100%;display:flex;flex-direction:column;justify-content:center;align-items:center;color:#f7768e;font-weight:bold;font-size:1.5rem;text-shadow:0 0 10px black;pointer-events:auto;">
                <div id="sell-zone-text"> / </div>
            </div>
        `;
            document.body.appendChild(gsz);

            const dropTarget = document.getElementById('sell-drop-target');
            dropTarget.ondragover = e => { e.preventDefault(); dropTarget.style.background = 'rgba(255,100,100,0.2)'; };
            dropTarget.ondragleave = () => { dropTarget.style.background = 'transparent'; };
            dropTarget.ondrop = e => {
                e.preventDefault();
                dropTarget.style.background = 'transparent';
                if (game.dragged) {
                    // Sell Unit
                    const u = game.dragged;
                    if (u.owner === 'player') {
                        const price = u.cost * u.starLevel;
                        game.gold += price;
                        game.removeUnit(u, 'player');
                        showToast(`: +${price}G`);
                        updateUI();
                    }
                    game.dragged = null;
                } else if (game.draggedItem) {
                    // Trash Item
                    game.inventory[game.draggedItem.index] = null;
                    showToast(``);
                    updateUI();
                    game.draggedItem = null;
                }
                if (typeof hideSellZone === 'function') hideSellZone();
            };

            window.showSellZone = (type) => {
                const el = document.getElementById('global-sell-zone');
                const txt = document.getElementById('sell-zone-text');
                if (type === 'unit') txt.textContent = '';
                else txt.textContent = '';
                el.style.display = 'flex';
                setTimeout(() => el.style.opacity = 1, 10);
            };
            window.hideSellZone = () => {
                const el = document.getElementById('global-sell-zone');
                if (el) {
                    el.style.opacity = 0;
                    setTimeout(() => el.style.display = 'none', 200);
                }
            };

            const oldSz = document.getElementById('sell-zone');
            if (oldSz) oldSz.style.display = 'none';

            // Mobile Navigation Control
            window.togglePanel = (panelId, btn) => {
                const p = document.getElementById(panelId);
                const allPanels = ['synergy-panel', 'item-guide-panel', 'inventory-container', 'synergy-list-container'];
                const isVis = p.classList.contains('mobile-visible');

                // Hide all
                allPanels.forEach(id => {
                    const el = document.getElementById(id);
                    if (el) el.classList.remove('mobile-visible');
                });
                document.querySelectorAll('#mobile-nav button').forEach(b => b.classList.remove('active'));

                // Toggle target
                if (!isVis) {
                    p.classList.add('mobile-visible');
                    if (btn) btn.classList.add('active');
                }
            };

            game.start();
        </script>


</body>

</html>
